{"/home/travis/build/npmtest/node-npmtest-cordova/test.js":"/* istanbul instrument in package npmtest_cordova */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova/lib.npmtest_cordova.js":"/* istanbul instrument in package npmtest_cordova */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova.__dirname + '/lib.npmtest_cordova.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova/cordova.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n// All cordova js API moved to cordova-lib. If you don't need the cordova CLI,\n// use cordova-lib directly.\n\nvar cordova_lib = require('cordova-lib');\nmodule.exports = cordova_lib.cordova;\n\n// Also export the cordova-lib so that downstream consumers of cordova lib and\n// CLI will be able to use CLI's cordova-lib and avoid the risk of having two\n// different versions of cordova-lib which would result in two instances of\n// \"events\" and can cause bad event handling.\nmodule.exports.cordova_lib = cordova_lib;\nmodule.exports.cli = require('./src/cli');\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/cordova-lib.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n// For now expose plugman and cordova just as they were in the old repos\n\n\nfunction addProperty(obj, property, modulePath) {\n    // Add properties as getter to delay load the modules on first invocation\n    Object.defineProperty(obj, property, {\n        configurable: true,\n        get: function () {\n            var module = require(modulePath);\n            // We do not need the getter any more\n            obj[property] = module;\n            return module;\n        }\n    });\n}\n\nexports = module.exports = {\n    set binname(name) {\n        this.cordova.binname = name;\n    },\n    get binname() {\n        return this.cordova.binname;\n    },\n    get events() { return require('cordova-common').events },\n    get configparser() { return require('cordova-common').ConfigParser },\n    get PluginInfo() { return require('cordova-common').PluginInfo },\n    get CordovaError() { return require('cordova-common').CordovaError }\n\n};\n\naddProperty(module.exports, 'plugman', './src/plugman/plugman');\naddProperty(module.exports, 'cordova', './src/cordova/cordova');\naddProperty(module.exports, 'cordova_platforms', './src/platforms/platforms');","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/src/cordova/cordova.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar cordova_events = require('cordova-common').events;\nvar cordova_util = require('./util');\n\nvar off = function() {\n    cordova_events.removeListener.apply(cordova_events, arguments);\n};\n\nvar emit = function() {\n    cordova_events.emit.apply(cordova_events, arguments);\n};\n\nexports = module.exports = {\n    get binname() { return cordova_util.binname; },\n    set binname(name) { cordova_util.binname = name; },\n    on:        function() {\n        cordova_events.on.apply(cordova_events, arguments);\n    },\n    off:       off,\n    removeListener:off,\n    removeAllListeners:function() {\n        cordova_events.removeAllListeners.apply(cordova_events, arguments);\n    },\n    emit:      emit,\n    trigger:   emit,\n    raw: {}\n};\n\nexports.findProjectRoot = function(opt_startDir) {\n    return cordova_util.isCordova(opt_startDir);\n};\n\n// Each of these APIs takes a final parameter that is a callback function.\n// The callback is passed the error object upon failure, or undefined upon success.\n// To use a promise instead, call the APIs via cordova.raw.FOO(), which returns\n// a promise instead of using a final-parameter-callback.\nvar addModuleProperty = cordova_util.addModuleProperty;\naddModuleProperty(module, 'prepare', './prepare', true);\naddModuleProperty(module, 'build', './build', true);\naddModuleProperty(module, 'help', './help');\naddModuleProperty(module, 'config', './config');\naddModuleProperty(module, 'create', './create', true);\naddModuleProperty(module, 'emulate', './emulate', true);\naddModuleProperty(module, 'plugin', './plugin', true);\naddModuleProperty(module, 'plugins', './plugin', true);\naddModuleProperty(module, 'serve', './serve');\naddModuleProperty(module, 'platform', './platform', true);\naddModuleProperty(module, 'platforms', './platform', true);\naddModuleProperty(module, 'compile', './compile', true);\naddModuleProperty(module, 'run', './run', true);\naddModuleProperty(module, 'info', './info', true);\naddModuleProperty(module, 'targets', './targets', true);\naddModuleProperty(module, 'requirements', './requirements', true);\naddModuleProperty(module, 'projectMetadata', './project_metadata', true);\naddModuleProperty(module, 'clean', './clean', true);\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/cordova-common.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar addProperty = require('./src/util/addProperty');\n\nmodule.exports = { };\n\naddProperty(module, 'events', './src/events');\naddProperty(module, 'superspawn', './src/superspawn');\n\naddProperty(module, 'ActionStack', './src/ActionStack');\naddProperty(module, 'CordovaError', './src/CordovaError/CordovaError');\naddProperty(module, 'CordovaLogger', './src/CordovaLogger');\naddProperty(module, 'CordovaCheck', './src/CordovaCheck');\naddProperty(module, 'CordovaExternalToolErrorContext', './src/CordovaError/CordovaExternalToolErrorContext');\naddProperty(module, 'PlatformJson', './src/PlatformJson');\naddProperty(module, 'ConfigParser', './src/ConfigParser/ConfigParser');\naddProperty(module, 'FileUpdater', './src/FileUpdater');\n\naddProperty(module, 'PluginInfo', './src/PluginInfo/PluginInfo');\naddProperty(module, 'PluginInfoProvider', './src/PluginInfo/PluginInfoProvider');\n\naddProperty(module, 'PluginManager', './src/PluginManager');\n\naddProperty(module, 'ConfigChanges', './src/ConfigChanges/ConfigChanges');\naddProperty(module, 'ConfigKeeper', './src/ConfigChanges/ConfigKeeper');\naddProperty(module, 'ConfigFile', './src/ConfigChanges/ConfigFile');\naddProperty(module, 'mungeUtil', './src/ConfigChanges/munge-util');\n\naddProperty(module, 'xmlHelpers', './src/util/xml-helpers');\n\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/util/addProperty.js":"/*\n       Licensed to the Apache Software Foundation (ASF) under one\n       or more contributor license agreements.  See the NOTICE file\n       distributed with this work for additional information\n       regarding copyright ownership.  The ASF licenses this file\n       to you under the Apache License, Version 2.0 (the\n       \"License\"); you may not use this file except in compliance\n       with the License.  You may obtain a copy of the License at\n\n         http://www.apache.org/licenses/LICENSE-2.0\n\n       Unless required by applicable law or agreed to in writing,\n       software distributed under the License is distributed on an\n       \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n       KIND, either express or implied.  See the License for the\n       specific language governing permissions and limitations\n       under the License.\n*/\n\nmodule.exports = function addProperty(module, property, modulePath, obj) {\n    \n    obj = obj || module.exports;\n    // Add properties as getter to delay load the modules on first invocation\n    Object.defineProperty(obj, property, {\n        configurable: true,\n        get: function () {\n            var delayLoadedModule = module.require(modulePath);\n            obj[property] = delayLoadedModule;\n            return delayLoadedModule;\n        }\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/events.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar INSTANCE = new EventEmitter();\nvar EVENTS_RECEIVER;\n\nmodule.exports = INSTANCE;\n\n/**\n * Sets up current instance to forward emitted events to another EventEmitter\n *   instance.\n *\n * @param   {EventEmitter}  [eventEmitter]  The emitter instance to forward\n *   events to. Falsy value, when passed, disables forwarding.\n */\nmodule.exports.forwardEventsTo = function (eventEmitter) {\n\n    // If no argument is specified disable events forwarding\n    if (!eventEmitter) {\n        EVENTS_RECEIVER = undefined;\n        return;\n    }\n\n    if (!(eventEmitter instanceof EventEmitter))\n        throw new Error('Cordova events can be redirected to another EventEmitter instance only');\n\n    // CB-10940 Skipping forwarding to self to avoid infinite recursion.\n    // This is the case when the modules are npm-linked.\n    if (this !== eventEmitter) {\n        EVENTS_RECEIVER = eventEmitter;\n    } else {\n        // Reset forwarding if we are subscribing to self\n        EVENTS_RECEIVER = undefined;\n    }\n};\n\nvar emit = INSTANCE.emit;\n\n/**\n * This method replaces original 'emit' method to allow events forwarding.\n *\n * @return  {eventEmitter}  Current instance to allow calls chaining, as\n *   original 'emit' does\n */\nmodule.exports.emit = function () {\n\n    var args = Array.prototype.slice.call(arguments);\n\n    if (EVENTS_RECEIVER) {\n        EVENTS_RECEIVER.emit.apply(EVENTS_RECEIVER, args);\n    }\n\n    return emit.apply(this, args);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/src/cordova/util.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true */\nvar fs            = require('fs'),\n    path          = require('path'),\n    events        = require('cordova-common').events,\n    CordovaError  = require('cordova-common').CordovaError,\n    shell         = require('shelljs'),\n    url           = require('url'),\n    nopt          = require('nopt'),\n    Q             = require('q'),\n    semver        = require('semver');\n\n// Global configuration paths\nvar global_config_path = process.env['CORDOVA_HOME'];\nif (!global_config_path) {\n    var HOME = process.env[(process.platform.slice(0, 3) == 'win') ? 'USERPROFILE' : 'HOME'];\n    global_config_path = path.join(HOME, '.cordova');\n}\n\nvar origCwd = null;\n\nvar lib_path = path.join(global_config_path, 'lib');\n\n\nexports.binname = 'cordova';\nexports.globalConfig = global_config_path;\n\n// defer defining libDirectory on exports so we don't create it if \n// someone simply requires this module\nObject.defineProperty(exports,'libDirectory', {\n        configurable: true,\n        get: function () {\n            shell.mkdir('-p', lib_path);\n            exports.libDirectory = lib_path;\n        return lib_path;\n    }\n});\n\naddModuleProperty(module, 'plugin_parser', './plugin_parser');\n\nexports.isCordova = isCordova;\nexports.cdProjectRoot = cdProjectRoot;\nexports.deleteSvnFolders = deleteSvnFolders;\nexports.listPlatforms = listPlatforms;\nexports.findPlugins = findPlugins;\nexports.appDir = appDir;\nexports.projectWww = projectWww;\nexports.projectConfig = projectConfig;\nexports.preProcessOptions = preProcessOptions;\nexports.addModuleProperty = addModuleProperty;\nexports.getOrigWorkingDirectory = getOrigWorkingDirectory;\nexports._resetOrigCwd = _resetOrigCwd;\nexports.fixRelativePath = fixRelativePath;\nexports.convertToRealPathSafe = convertToRealPathSafe;\nexports.isDirectory = isDirectory;\nexports.isUrl = isUrl;\nexports.getLatestMatchingNpmVersion = getLatestMatchingNpmVersion;\nexports.getAvailableNpmVersions = getAvailableNpmVersions;\nexports.getInstalledPlatformsWithVersions = getInstalledPlatformsWithVersions;\nexports.existsSync = existsSync;\n\nfunction isUrl(value) {\n    var u = value && url.parse(value);\n    return !!(u && u.protocol && u.protocol.length > 2); // Account for windows c:/ paths\n}\n\nfunction isRootDir(dir) {\n    if (exports.existsSync(path.join(dir, 'www'))) {\n        if (exports.existsSync(path.join(dir, 'config.xml'))) {\n            // For sure is.\n            if (exports.existsSync(path.join(dir, 'platforms'))) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        // Might be (or may be under platforms/).\n        if (exports.existsSync(path.join(dir, 'www', 'config.xml'))) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nfunction existsSync(fileSpec) {\n    // Since fs.existsSync() is deprecated\n    try {\n        fs.statSync(fileSpec);\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n\n\n// Runs up the directory chain looking for a .cordova directory.\n// IF it is found we are in a Cordova project.\n// Omit argument to use CWD.\nfunction isCordova(dir) {\n    if (!dir) {\n        // Prefer PWD over cwd so that symlinked dirs within your PWD work correctly (CB-5687).\n        var pwd = process.env.PWD;\n        var cwd = process.cwd();\n        if (pwd && pwd != cwd && pwd != 'undefined') {\n            return this.isCordova(pwd) || this.isCordova(cwd);\n        }\n        return this.isCordova(cwd);\n    }\n    var bestReturnValueSoFar = false;\n    for (var i = 0; i < 1000; ++i) {\n        var result = isRootDir(dir);\n        if (result === 2) {\n            return dir;\n        }\n        if (result === 1) {\n            bestReturnValueSoFar = dir;\n        }\n        var parentDir = path.normalize(path.join(dir, '..'));\n        // Detect fs root.\n        if (parentDir == dir) {\n            return bestReturnValueSoFar;\n        }\n        dir = parentDir;\n    }\n    console.error('Hit an unhandled case in util.isCordova');\n    return false;\n}\n\n// Cd to project root dir and return its path. Throw CordovaError if not in a Corodva project.\nfunction cdProjectRoot() {\n    var projectRoot = this.isCordova();\n    if (!projectRoot) {\n        throw new CordovaError('Current working directory is not a Cordova-based project.');\n    }\n    if (!origCwd) {\n        origCwd = process.env.PWD || process.cwd();\n    }\n    process.env.PWD = projectRoot;\n    process.chdir(projectRoot);\n    return projectRoot;\n}\n\nfunction getOrigWorkingDirectory() {\n    return origCwd || process.env.PWD || process.cwd();\n}\n\nfunction _resetOrigCwd() {\n    origCwd = null;\n}\n\n// Fixes up relative paths that are no longer valid due to chdir() within cdProjectRoot().\nfunction fixRelativePath(value, /* optional */ cwd) {\n    // Don't touch absolute paths.\n    if (value[1] == ':' || value[0] == path.sep) {\n        return value;\n    }\n    var newDir = cwd || process.env.PWD || process.cwd();\n    var origDir = getOrigWorkingDirectory();\n    var pathDiff = path.relative(newDir, origDir);\n    var ret = path.normalize(path.join(pathDiff, value));\n    return ret;\n}\n\n// Resolve any symlinks in order to avoid relative path issues. See https://issues.apache.org/jira/browse/CB-8757\nfunction convertToRealPathSafe(path) {\n    if (path && exports.existsSync(path)) {\n        return fs.realpathSync(path);\n    }\n\n    return path;\n}\n\n// Recursively deletes .svn folders from a target path\nfunction deleteSvnFolders(dir) {\n    var contents = fs.readdirSync(dir);\n    contents.forEach(function(entry) {\n        var fullpath = path.join(dir, entry);\n        if (fs.statSync(fullpath).isDirectory()) {\n            if (entry == '.svn') {\n                shell.rm('-rf', fullpath);\n            } else module.exports.deleteSvnFolders(fullpath);\n        }\n    });\n}\n\nfunction listPlatforms(project_dir) {\n    var core_platforms = require('../platforms/platforms');\n    var platforms_dir = path.join(project_dir, 'platforms');\n    if ( !exports.existsSync(platforms_dir)) {\n        return [];\n    }\n    var subdirs = fs.readdirSync(platforms_dir);\n    return subdirs.filter(function(p) {\n        return Object.keys(core_platforms).indexOf(p) > -1;\n    });\n}\n\nfunction getInstalledPlatformsWithVersions(project_dir) {\n    var result = {};\n    var platforms_on_fs = listPlatforms(project_dir);\n\n    return Q.all(platforms_on_fs.map(function(p) {\n        var superspawn    = require('cordova-common').superspawn;\n        return superspawn.maybeSpawn(path.join(project_dir, 'platforms', p, 'cordova', 'version'), [], { chmod: true })\n        .then(function(v) {\n            result[p] = v || null;\n        }, function(v) {\n            result[p] = 'broken';\n        });\n    })).then(function() {\n        return result;\n    });\n}\n\n// list the directories in the path, ignoring any files\nfunction findPlugins(pluginPath) {\n    var plugins = [],\n        stats;\n\n    if (exports.existsSync(pluginPath)) {\n        plugins = fs.readdirSync(pluginPath).filter(function (fileName) {\n            stats = fs.statSync(path.join(pluginPath, fileName));\n            return fileName != '.svn' && fileName != 'CVS' && stats.isDirectory();\n        });\n    }\n\n    return plugins;\n}\n\nfunction appDir(projectDir) {\n    return projectDir;\n}\n\nfunction projectWww(projectDir) {\n    return path.join(projectDir, 'www');\n}\n\nfunction projectConfig(projectDir) {\n    var rootPath = path.join(projectDir, 'config.xml');\n    var wwwPath = path.join(projectDir, 'www', 'config.xml');\n    if (exports.existsSync(rootPath)) {\n        return rootPath;\n    } else if (exports.existsSync(wwwPath)) {\n        return wwwPath;\n    }\n    return false;\n}\n\nfunction preProcessOptions (inputOptions) {\n    /**\n     * Current Desired Arguments\n     * options: {verbose: boolean, platforms: [String], options: [String]}\n     * Accepted Arguments\n     * platformList: [String] -- assume just a list of platforms\n     * platform: String -- assume this is a platform\n     */\n    var result = inputOptions || {};\n    if (Array.isArray(inputOptions)) {\n        result = { platforms: inputOptions };\n    } else if (typeof inputOptions === 'string') {\n        result = { platforms: [inputOptions] };\n    }\n    result.verbose = result.verbose || false;\n    result.platforms = result.platforms || [];\n    result.options = ensurePlatformOptionsCompatible(result.options);\n\n    var projectRoot = this.isCordova();\n\n    if (!projectRoot) {\n        throw new CordovaError('Current working directory is not a Cordova-based project.');\n    }\n    var projectPlatforms = this.listPlatforms(projectRoot);\n    if (projectPlatforms.length === 0) {\n        throw new CordovaError('No platforms added to this project. Please use `'+exports.binname+' platform add <platform>`.');\n    }\n    if (result.platforms.length === 0) {\n        result.platforms = projectPlatforms;\n    }\n\n    if (!result.options.buildConfig && exports.existsSync(path.join(projectRoot, 'build.json'))) {\n        result.options.buildConfig = path.join(projectRoot, 'build.json');\n    }\n\n    return result;\n}\n\n/**\n * Converts options, which is passed to platformApi from old format (array of\n *   plain strings) to new - nopt-parsed object + array of platform-specific\n *   options. If options are already in new the format - returns them unchanged.\n *\n * @param   {Object|String[]}  platformOptions  A platform options (array of\n *   strings or object) which is passed down to platform scripts/platformApi\n *   polyfill.\n *\n * @return  {Object}                            Options, converted to new format\n */\nfunction ensurePlatformOptionsCompatible (platformOptions) {\n    var opts = platformOptions || {};\n\n    if (!Array.isArray(opts))\n        return opts;\n\n    events.emit('warn', 'The format of cordova.raw.* methods \"options\" argument was changed in 5.4.0. ' +\n        '\"options.options\" property now should be an object instead of an array of plain strings. Though the old format ' +\n        'is still supported, consider updating your cordova.raw.* method calls to use new argument format.');\n\n    var knownArgs = [\n        'debug',\n        'release',\n        'device',\n        'emulator',\n        'nobuild',\n        'list',\n        'buildConfig',\n        'target',\n        'archs'\n    ];\n\n    opts = nopt({}, {}, opts, 0);\n    opts.argv = Object.keys(opts)\n    .filter(function (arg) {\n        return arg !== 'argv' && knownArgs.indexOf(arg) === -1;\n    }).map(function (arg) {\n        return opts[arg] === true ?\n            '--' + arg :\n            '--' + arg + '=' + opts[arg].toString();\n    });\n\n    return opts;\n}\n\nfunction isDirectory(dir) {\n    try {\n        return fs.lstatSync(dir).isDirectory();\n    } catch (e) {\n        return false;\n    }\n}\n\n// opt_wrap is a boolean: True means that a callback-based wrapper for the promise-based function\n// should be created.\nfunction addModuleProperty(module, symbol, modulePath, opt_wrap, opt_obj) {\n    var val = null;\n    if (opt_wrap) {\n        module.exports[symbol] = function() {\n            val = val || module.require(modulePath);\n            if (arguments.length && typeof arguments[arguments.length - 1] === 'function') {\n                // If args exist and the last one is a function, it's the callback.\n                var args = Array.prototype.slice.call(arguments);\n                var cb = args.pop();\n                val.apply(module.exports, args).done(function(result) { cb(undefined, result); }, cb);\n            } else {\n                val.apply(module.exports, arguments).done(null, function(err) { throw err; });\n            }\n        };\n    } else {\n        Object.defineProperty(opt_obj || module.exports, symbol, {\n            get : function() { val = val || module.require(modulePath); return val; },\n            set : function(v) { val = v; }\n        });\n    }\n\n    // Add the module.raw.foo as well.\n    if(module.exports.raw) {\n        Object.defineProperty(module.exports.raw, symbol, {\n            get : function() { val = val || module.require(modulePath); return val; },\n            set : function(v) { val = v; }\n        });\n    }\n}\n\n/**\n * Returns the latest version of the specified module on npm that matches the specified version or range.\n * @param {string} module_name - npm module name.\n * @param {string} version - semver version or range (loose allowed).\n * @returns {Promise} Promise for version (a valid semver version if one is found, otherwise whatever was provided).\n */\nfunction getLatestMatchingNpmVersion(module_name, version) {\n    if (!version) {\n        // If no version specified, get the latest\n        return getLatestNpmVersion(module_name);\n    }\n\n    var validVersion = semver.valid(version, /* loose */ true);\n    if (validVersion) {\n        // This method is really intended to work with ranges, so if a version rather than a range is specified, we just\n        // assume it is available and return it, bypassing the need for the npm call.\n        return Q(validVersion);\n    }\n\n    var validRange = semver.validRange(version, /* loose */ true);\n    if (!validRange) {\n        // Just return what we were passed\n        return Q(version);\n    }\n\n    return getAvailableNpmVersions(module_name).then(function (versions) {\n        return semver.maxSatisfying(versions, validRange) || version;\n    });\n}\n\n/**\n * Returns a promise for an array of versions available for the specified npm module.\n * @param {string} module_name - npm module name.\n * @returns {Promise} Promise for an array of versions.\n */\nfunction getAvailableNpmVersions(module_name) {\n    var npm = require('npm');\n    return Q.nfcall(npm.load).then(function () {\n        return Q.ninvoke(npm.commands, 'view', [module_name, 'versions'], /* silent = */ true).then(function (result) {\n            // result is an object in the form:\n            //     {'<version>': {versions: ['1.2.3', '1.2.4', ...]}}\n            // (where <version> is the latest version)\n            return result[Object.keys(result)[0]].versions;\n        });\n    });\n}\n\n/**\n * Returns a promise for the latest version available for the specified npm module.\n * @param {string} module_name - npm module name.\n * @returns {Promise} Promise for an array of versions.\n */\nfunction getLatestNpmVersion(module_name) {\n    var npm = require('npm');\n    return Q.nfcall(npm.load).then(function () {\n        return Q.ninvoke(npm.commands, 'view', [module_name, 'version'], /* silent = */ true).then(function (result) {\n            // result is an object in the form:\n            //     {'<version>': {version: '<version>'}}\n            // (where <version> is the latest version)\n            return Object.keys(result)[0];\n        });\n    });\n}\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/CordovaError/CordovaError.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint proto:true */\n\nvar EOL = require('os').EOL;\n\n/**\n * A derived exception class. See usage example in cli.js\n * Based on:\n * stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript/8460753#8460753\n * @param {String} message Error message\n * @param {Number} [code=0] Error code\n * @param {CordovaExternalToolErrorContext} [context] External tool error context object\n * @constructor\n */\nfunction CordovaError(message, code, context) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.code = code || CordovaError.UNKNOWN_ERROR;\n    this.context = context;\n}\nCordovaError.prototype.__proto__ = Error.prototype;\n\n// TODO: Extend error codes according the projects specifics\nCordovaError.UNKNOWN_ERROR = 0;\nCordovaError.EXTERNAL_TOOL_ERROR = 1;\n\n/**\n * Translates instance's error code number into error code name, e.g. 0 -> UNKNOWN_ERROR\n * @returns {string} Error code string name\n */\nCordovaError.prototype.getErrorCodeName = function() {\n    for(var key in CordovaError) {\n        if(CordovaError.hasOwnProperty(key)) {\n            if(CordovaError[key] === this.code) {\n                return key;\n            }\n        }\n    }\n};\n\n/**\n * Converts CordovaError instance to string representation\n * @param   {Boolean}  [isVerbose]  Set up verbose mode. Used to provide more\n *   details including information about error code name and context\n * @return  {String}              Stringified error representation\n */\nCordovaError.prototype.toString = function(isVerbose) {\n    var message = '', codePrefix = '';\n\n    if(this.code !== CordovaError.UNKNOWN_ERROR) {\n        codePrefix = 'code: ' + this.code + (isVerbose ? (' (' + this.getErrorCodeName() + ')') : '') + ' ';\n    }\n\n    if(this.code === CordovaError.EXTERNAL_TOOL_ERROR) {\n        if(typeof this.context !== 'undefined') {\n            if(isVerbose) {\n                message = codePrefix + EOL + this.context.toString(isVerbose) + '\\n failed with an error: ' +\n                    this.message + EOL + 'Stack trace: ' + this.stack;\n            } else {\n                message = codePrefix + '\\'' + this.context.toString(isVerbose) + '\\' ' + this.message;\n            }\n        } else {\n            message = 'External tool failed with an error: ' + this.message;\n        }\n    } else {\n        message = isVerbose ? codePrefix + this.stack : codePrefix + this.message;\n    }\n\n    return message;\n};\n\nmodule.exports = CordovaError;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/shell.js":"//\n// ShellJS\n// Unix shell commands on top of Node's API\n//\n// Copyright (c) 2012 Artur Adib\n// http://github.com/arturadib/shelljs\n//\n\nvar common = require('./src/common');\n\n\n//@\n//@ All commands run synchronously, unless otherwise stated.\n//@\n\n//@include ./src/cd\nvar _cd = require('./src/cd');\nexports.cd = common.wrap('cd', _cd);\n\n//@include ./src/pwd\nvar _pwd = require('./src/pwd');\nexports.pwd = common.wrap('pwd', _pwd);\n\n//@include ./src/ls\nvar _ls = require('./src/ls');\nexports.ls = common.wrap('ls', _ls);\n\n//@include ./src/find\nvar _find = require('./src/find');\nexports.find = common.wrap('find', _find);\n\n//@include ./src/cp\nvar _cp = require('./src/cp');\nexports.cp = common.wrap('cp', _cp);\n\n//@include ./src/rm\nvar _rm = require('./src/rm');\nexports.rm = common.wrap('rm', _rm);\n\n//@include ./src/mv\nvar _mv = require('./src/mv');\nexports.mv = common.wrap('mv', _mv);\n\n//@include ./src/mkdir\nvar _mkdir = require('./src/mkdir');\nexports.mkdir = common.wrap('mkdir', _mkdir);\n\n//@include ./src/test\nvar _test = require('./src/test');\nexports.test = common.wrap('test', _test);\n\n//@include ./src/cat\nvar _cat = require('./src/cat');\nexports.cat = common.wrap('cat', _cat);\n\n//@include ./src/to\nvar _to = require('./src/to');\nString.prototype.to = common.wrap('to', _to);\n\n//@include ./src/toEnd\nvar _toEnd = require('./src/toEnd');\nString.prototype.toEnd = common.wrap('toEnd', _toEnd);\n\n//@include ./src/sed\nvar _sed = require('./src/sed');\nexports.sed = common.wrap('sed', _sed);\n\n//@include ./src/grep\nvar _grep = require('./src/grep');\nexports.grep = common.wrap('grep', _grep);\n\n//@include ./src/which\nvar _which = require('./src/which');\nexports.which = common.wrap('which', _which);\n\n//@include ./src/echo\nvar _echo = require('./src/echo');\nexports.echo = _echo; // don't common.wrap() as it could parse '-options'\n\n//@include ./src/dirs\nvar _dirs = require('./src/dirs').dirs;\nexports.dirs = common.wrap(\"dirs\", _dirs);\nvar _pushd = require('./src/dirs').pushd;\nexports.pushd = common.wrap('pushd', _pushd);\nvar _popd = require('./src/dirs').popd;\nexports.popd = common.wrap(\"popd\", _popd);\n\n//@include ./src/ln\nvar _ln = require('./src/ln');\nexports.ln = common.wrap('ln', _ln);\n\n//@\n//@ ### exit(code)\n//@ Exits the current process with the given exit code.\nexports.exit = process.exit;\n\n//@\n//@ ### env['VAR_NAME']\n//@ Object containing environment variables (both getter and setter). Shortcut to process.env.\nexports.env = process.env;\n\n//@include ./src/exec\nvar _exec = require('./src/exec');\nexports.exec = common.wrap('exec', _exec, {notUnix:true});\n\n//@include ./src/chmod\nvar _chmod = require('./src/chmod');\nexports.chmod = common.wrap('chmod', _chmod);\n\n\n\n//@\n//@ ## Non-Unix commands\n//@\n\n//@include ./src/tempdir\nvar _tempDir = require('./src/tempdir');\nexports.tempdir = common.wrap('tempdir', _tempDir);\n\n\n//@include ./src/error\nvar _error = require('./src/error');\nexports.error = _error;\n\n\n\n//@\n//@ ## Configuration\n//@\n\nexports.config = common.config;\n\n//@\n//@ ### config.silent\n//@ Example:\n//@\n//@ ```javascript\n//@ var silentState = config.silent; // save old silent state\n//@ config.silent = true;\n//@ /* ... */\n//@ config.silent = silentState; // restore old silent state\n//@ ```\n//@\n//@ Suppresses all command output if `true`, except for `echo()` calls.\n//@ Default is `false`.\n\n//@\n//@ ### config.fatal\n//@ Example:\n//@\n//@ ```javascript\n//@ config.fatal = true;\n//@ cp('this_file_does_not_exist', '/dev/null'); // dies here\n//@ /* more commands... */\n//@ ```\n//@\n//@ If `true` the script will die on errors. Default is `false`.\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/common.js":"var os = require('os');\nvar fs = require('fs');\nvar _ls = require('./ls');\n\n// Module globals\nvar config = {\n  silent: false,\n  fatal: false\n};\nexports.config = config;\n\nvar state = {\n  error: null,\n  currentCmd: 'shell.js',\n  tempDir: null\n};\nexports.state = state;\n\nvar platform = os.type().match(/^Win/) ? 'win' : 'unix';\nexports.platform = platform;\n\nfunction log() {\n  if (!config.silent)\n    console.log.apply(this, arguments);\n}\nexports.log = log;\n\n// Shows error message. Throws unless _continue or config.fatal are true\nfunction error(msg, _continue) {\n  if (state.error === null)\n    state.error = '';\n  state.error += state.currentCmd + ': ' + msg + '\\n';\n\n  if (msg.length > 0)\n    log(state.error);\n\n  if (config.fatal)\n    process.exit(1);\n\n  if (!_continue)\n    throw '';\n}\nexports.error = error;\n\n// In the future, when Proxies are default, we can add methods like `.to()` to primitive strings.\n// For now, this is a dummy function to bookmark places we need such strings\nfunction ShellString(str) {\n  return str;\n}\nexports.ShellString = ShellString;\n\n// Returns {'alice': true, 'bob': false} when passed a dictionary, e.g.:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\nfunction parseOptions(str, map) {\n  if (!map)\n    error('parseOptions() internal error: no map given');\n\n  // All options are false by default\n  var options = {};\n  for (var letter in map)\n    options[map[letter]] = false;\n\n  if (!str)\n    return options; // defaults\n\n  if (typeof str !== 'string')\n    error('parseOptions() internal error: wrong str');\n\n  // e.g. match[1] = 'Rf' for str = '-Rf'\n  var match = str.match(/^\\-(.+)/);\n  if (!match)\n    return options;\n\n  // e.g. chars = ['R', 'f']\n  var chars = match[1].split('');\n\n  chars.forEach(function(c) {\n    if (c in map)\n      options[map[c]] = true;\n    else\n      error('option not recognized: '+c);\n  });\n\n  return options;\n}\nexports.parseOptions = parseOptions;\n\n// Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\nfunction expand(list) {\n  var expanded = [];\n  list.forEach(function(listEl) {\n    // Wildcard present on directory names ?\n    if(listEl.search(/\\*[^\\/]*\\//) > -1 || listEl.search(/\\*\\*[^\\/]*\\//) > -1) {\n      var match = listEl.match(/^([^*]+\\/|)(.*)/);\n      var root = match[1];\n      var rest = match[2];\n      var restRegex = rest.replace(/\\*\\*/g, \".*\").replace(/\\*/g, \"[^\\\\/]*\");\n      restRegex = new RegExp(restRegex);\n      \n      _ls('-R', root).filter(function (e) {\n        return restRegex.test(e);\n      }).forEach(function(file) {\n        expanded.push(file);\n      });\n    }\n    // Wildcard present on file names ?\n    else if (listEl.search(/\\*/) > -1) {\n      _ls('', listEl).forEach(function(file) {\n        expanded.push(file);\n      });\n    } else {\n      expanded.push(listEl);\n    }\n  });\n  return expanded;\n}\nexports.expand = expand;\n\n// Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch(e) {\n    // Try to override file permission\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\nexports.unlinkSync = unlinkSync;\n\n// e.g. 'shelljs_a5f185d0443ca...'\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1)\n      return parseInt(16*Math.random(), 10).toString(16);\n    else {\n      var hash = '';\n      for (var i=0; i<count; i++)\n        hash += randomHash(1);\n      return hash;\n    }\n  }\n\n  return 'shelljs_'+randomHash(20);\n}\nexports.randomFileName = randomFileName;\n\n// extend(target_obj, source_obj1 [, source_obj2 ...])\n// Shallow extend, e.g.:\n//    extend({A:1}, {b:2}, {c:3}) returns {A:1, b:2, c:3}\nfunction extend(target) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function(source) {\n    for (var key in source)\n      target[key] = source[key];\n  });\n\n  return target;\n}\nexports.extend = extend;\n\n// Common wrapper for all Unix-like commands\nfunction wrap(cmd, fn, options) {\n  return function() {\n    var retValue = null;\n\n    state.currentCmd = cmd;\n    state.error = null;\n\n    try {\n      var args = [].slice.call(arguments, 0);\n\n      if (options && options.notUnix) {\n        retValue = fn.apply(this, args);\n      } else {\n        if (args.length === 0 || typeof args[0] !== 'string' || args[0][0] !== '-')\n          args.unshift(''); // only add dummy option if '-option' not already present\n        retValue = fn.apply(this, args);\n      }\n    } catch (e) {\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        console.log('shell.js: internal error');\n        console.log(e.stack || e);\n        process.exit(1);\n      }\n      if (config.fatal)\n        throw e;\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\nexports.wrap = wrap;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/ls.js":"var path = require('path');\nvar fs = require('fs');\nvar common = require('./common');\nvar _cd = require('./cd');\nvar _pwd = require('./pwd');\n\n//@\n//@ ### ls([options ,] path [,path ...])\n//@ ### ls([options ,] path_array)\n//@ Available options:\n//@\n//@ + `-R`: recursive\n//@ + `-A`: all files (include files beginning with `.`, except for `.` and `..`)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ls('projs/*.js');\n//@ ls('-R', '/users/me', '/tmp');\n//@ ls('-R', ['/users/me', '/tmp']); // same as above\n//@ ```\n//@\n//@ Returns array of files in the given path, or in current directory if no path provided.\nfunction _ls(options, paths) {\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'A': 'all',\n    'a': 'all_deprecated'\n  });\n\n  if (options.all_deprecated) {\n    // We won't support the -a option as it's hard to image why it's useful\n    // (it includes '.' and '..' in addition to '.*' files)\n    // For backwards compatibility we'll dump a deprecated message and proceed as before\n    common.log('ls: Option -a is deprecated. Use -A instead');\n    options.all = true;\n  }\n\n  if (!paths)\n    paths = ['.'];\n  else if (typeof paths === 'object')\n    paths = paths; // assume array\n  else if (typeof paths === 'string')\n    paths = [].slice.call(arguments, 1);\n\n  var list = [];\n\n  // Conditionally pushes file to list - returns true if pushed, false otherwise\n  // (e.g. prevents hidden files to be included unless explicitly told so)\n  function pushFile(file, query) {\n    // hidden file?\n    if (path.basename(file)[0] === '.') {\n      // not explicitly asking for hidden files?\n      if (!options.all && !(path.basename(query)[0] === '.' && path.basename(query).length > 1))\n        return false;\n    }\n\n    if (common.platform === 'win')\n      file = file.replace(/\\\\/g, '/');\n\n    list.push(file);\n    return true;\n  }\n\n  paths.forEach(function(p) {\n    if (fs.existsSync(p)) {\n      var stats = fs.statSync(p);\n      // Simple file?\n      if (stats.isFile()) {\n        pushFile(p, p);\n        return; // continue\n      }\n\n      // Simple dir?\n      if (stats.isDirectory()) {\n        // Iterate over p contents\n        fs.readdirSync(p).forEach(function(file) {\n          if (!pushFile(file, p))\n            return;\n\n          // Recursive?\n          if (options.recursive) {\n            var oldDir = _pwd();\n            _cd('', p);\n            if (fs.statSync(file).isDirectory())\n              list = list.concat(_ls('-R'+(options.all?'A':''), file+'/*'));\n            _cd('', oldDir);\n          }\n        });\n        return; // continue\n      }\n    }\n\n    // p does not exist - possible wildcard present\n\n    var basename = path.basename(p);\n    var dirname = path.dirname(p);\n    // Wildcard present on an existing dir? (e.g. '/tmp/*.js')\n    if (basename.search(/\\*/) > -1 && fs.existsSync(dirname) && fs.statSync(dirname).isDirectory) {\n      // Escape special regular expression chars\n      var regexp = basename.replace(/(\\^|\\$|\\(|\\)|<|>|\\[|\\]|\\{|\\}|\\.|\\+|\\?)/g, '\\\\$1');\n      // Translates wildcard into regex\n      regexp = '^' + regexp.replace(/\\*/g, '.*') + '$';\n      // Iterate over directory contents\n      fs.readdirSync(dirname).forEach(function(file) {\n        if (file.match(new RegExp(regexp))) {\n          if (!pushFile(path.normalize(dirname+'/'+file), basename))\n            return;\n\n          // Recursive?\n          if (options.recursive) {\n            var pp = dirname + '/' + file;\n            if (fs.lstatSync(pp).isDirectory())\n              list = list.concat(_ls('-R'+(options.all?'A':''), pp+'/*'));\n          } // recursive\n        } // if file matches\n      }); // forEach\n      return;\n    }\n\n    common.error('no such file or directory: ' + p, true);\n  });\n\n  return list;\n}\nmodule.exports = _ls;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/cd.js":"var fs = require('fs');\nvar common = require('./common');\n\n//@\n//@ ### cd('dir')\n//@ Changes to directory `dir` for the duration of the script\nfunction _cd(options, dir) {\n  if (!dir)\n    common.error('directory not specified');\n\n  if (!fs.existsSync(dir))\n    common.error('no such file or directory: ' + dir);\n\n  if (!fs.statSync(dir).isDirectory())\n    common.error('not a directory: ' + dir);\n\n  process.chdir(dir);\n}\nmodule.exports = _cd;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/pwd.js":"var path = require('path');\nvar common = require('./common');\n\n//@\n//@ ### pwd()\n//@ Returns the current directory.\nfunction _pwd(options) {\n  var pwd = path.resolve(process.cwd());\n  return common.ShellString(pwd);\n}\nmodule.exports = _pwd;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/find.js":"var fs = require('fs');\nvar common = require('./common');\nvar _ls = require('./ls');\n\n//@\n//@ ### find(path [,path ...])\n//@ ### find(path_array)\n//@ Examples:\n//@\n//@ ```javascript\n//@ find('src', 'lib');\n//@ find(['src', 'lib']); // same as above\n//@ find('.').filter(function(file) { return file.match(/\\.js$/); });\n//@ ```\n//@\n//@ Returns array of all files (however deep) in the given paths.\n//@\n//@ The main difference from `ls('-R', path)` is that the resulting file names\n//@ include the base directories, e.g. `lib/resources/file1` instead of just `file1`.\nfunction _find(options, paths) {\n  if (!paths)\n    common.error('no path specified');\n  else if (typeof paths === 'object')\n    paths = paths; // assume array\n  else if (typeof paths === 'string')\n    paths = [].slice.call(arguments, 1);\n\n  var list = [];\n\n  function pushFile(file) {\n    if (common.platform === 'win')\n      file = file.replace(/\\\\/g, '/');\n    list.push(file);\n  }\n\n  // why not simply do ls('-R', paths)? because the output wouldn't give the base dirs\n  // to get the base dir in the output, we need instead ls('-R', 'dir/*') for every directory\n\n  paths.forEach(function(file) {\n    pushFile(file);\n\n    if (fs.statSync(file).isDirectory()) {\n      _ls('-RA', file+'/*').forEach(function(subfile) {\n        pushFile(subfile);\n      });\n    }\n  });\n\n  return list;\n}\nmodule.exports = _find;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/cp.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar os = require('os');\n\n// Buffered file copy, synchronous\n// (Using readFileSync() + writeFileSync() could easily cause a memory overflow\n//  with large files)\nfunction copyFileSync(srcFile, destFile) {\n  if (!fs.existsSync(srcFile))\n    common.error('copyFileSync: no such file or directory: ' + srcFile);\n\n  var BUF_LENGTH = 64*1024,\n      buf = new Buffer(BUF_LENGTH),\n      bytesRead = BUF_LENGTH,\n      pos = 0,\n      fdr = null,\n      fdw = null;\n\n  try {\n    fdr = fs.openSync(srcFile, 'r');\n  } catch(e) {\n    common.error('copyFileSync: could not read src file ('+srcFile+')');\n  }\n\n  try {\n    fdw = fs.openSync(destFile, 'w');\n  } catch(e) {\n    common.error('copyFileSync: could not write to dest file (code='+e.code+'):'+destFile);\n  }\n\n  while (bytesRead === BUF_LENGTH) {\n    bytesRead = fs.readSync(fdr, buf, 0, BUF_LENGTH, pos);\n    fs.writeSync(fdw, buf, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  fs.closeSync(fdw);\n\n  fs.chmodSync(destFile, fs.statSync(srcFile).mode);\n}\n\n// Recursively copies 'sourceDir' into 'destDir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction cpdirSyncRecursive(sourceDir, destDir, opts) {\n  if (!opts) opts = {};\n\n  /* Create the directory where all our junk is moving to; read the mode of the source directory and mirror it */\n  var checkDir = fs.statSync(sourceDir);\n  try {\n    fs.mkdirSync(destDir, checkDir.mode);\n  } catch (e) {\n    //if the directory already exists, that's okay\n    if (e.code !== 'EEXIST') throw e;\n  }\n\n  var files = fs.readdirSync(sourceDir);\n\n  for (var i = 0; i < files.length; i++) {\n    var srcFile = sourceDir + \"/\" + files[i];\n    var destFile = destDir + \"/\" + files[i];\n    var srcFileStat = fs.lstatSync(srcFile);\n\n    if (srcFileStat.isDirectory()) {\n      /* recursion this thing right on back. */\n      cpdirSyncRecursive(srcFile, destFile, opts);\n    } else if (srcFileStat.isSymbolicLink()) {\n      var symlinkFull = fs.readlinkSync(srcFile);\n      fs.symlinkSync(symlinkFull, destFile, os.platform() === \"win32\" ? \"junction\" : null);\n    } else {\n      /* At this point, we've hit a file actually worth copying... so copy it on over. */\n      if (fs.existsSync(destFile) && !opts.force) {\n        common.log('skipping existing file: ' + files[i]);\n      } else {\n        copyFileSync(srcFile, destFile);\n      }\n    }\n\n  } // for files\n} // cpdirSyncRecursive\n\n\n//@\n//@ ### cp([options ,] source [,source ...], dest)\n//@ ### cp([options ,] source_array, dest)\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cp('file1', 'dir1');\n//@ cp('-Rf', '/tmp/*', '/usr/local/*', '/home/tmp');\n//@ cp('-Rf', ['/tmp/*', '/usr/local/*'], '/home/tmp'); // same as above\n//@ ```\n//@\n//@ Copies files. The wildcard `*` is accepted.\nfunction _cp(options, sources, dest) {\n  options = common.parseOptions(options, {\n    'f': 'force',\n    'R': 'recursive',\n    'r': 'recursive'\n  });\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else if ('length' in sources) {\n    sources = sources; // no-op for array\n  } else {\n    common.error('invalid arguments');\n  }\n\n  var exists = fs.existsSync(dest),\n      stats = exists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1)\n    common.error('dest is not a directory (too many sources)');\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && !options.force)\n    common.error('dest file already exists: ' + dest);\n\n  if (options.recursive) {\n    // Recursive allows the shortcut syntax \"sourcedir/\" for \"sourcedir/*\"\n    // (see Github issue #15)\n    sources.forEach(function(src, i) {\n      if (src[src.length - 1] === '/')\n        sources[i] += '*';\n    });\n\n    // Create dest\n    try {\n      fs.mkdirSync(dest, parseInt('0777', 8));\n    } catch (e) {\n      // like Unix's cp, keep going even if we can't create dest dir\n    }\n  }\n\n  sources = common.expand(sources);\n\n  sources.forEach(function(src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: '+src, true);\n      return; // skip file\n    }\n\n    // If here, src exists\n    if (fs.statSync(src).isDirectory()) {\n      if (!options.recursive) {\n        // Non-Recursive\n        common.log(src + ' is a directory (not copied)');\n      } else {\n        // Recursive\n        // 'cp /a/source dest' should create 'source' in 'dest'\n        var newDest = path.join(dest, path.basename(src)),\n            checkDir = fs.statSync(src);\n        try {\n          fs.mkdirSync(newDest, checkDir.mode);\n        } catch (e) {\n          //if the directory already exists, that's okay\n          if (e.code !== 'EEXIST') throw e;\n        }\n\n        cpdirSyncRecursive(src, newDest, {force: options.force});\n      }\n      return; // done with dir\n    }\n\n    // If here, src is a file\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory())\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n\n    if (fs.existsSync(thisDest) && !options.force) {\n      common.error('dest file already exists: ' + thisDest, true);\n      return; // skip file\n    }\n\n    copyFileSync(src, thisDest);\n  }); // forEach(src)\n}\nmodule.exports = _cp;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/rm.js":"var common = require('./common');\nvar fs = require('fs');\n\n// Recursively removes 'dir'\n// Adapted from https://github.com/ryanmcgrath/wrench-js\n//\n// Copyright (c) 2010 Ryan McGrath\n// Copyright (c) 2012 Artur Adib\n//\n// Licensed under the MIT License\n// http://www.opensource.org/licenses/mit-license.php\nfunction rmdirSyncRecursive(dir, force) {\n  var files;\n\n  files = fs.readdirSync(dir);\n\n  // Loop through and delete everything in the sub-tree after checking it\n  for(var i = 0; i < files.length; i++) {\n    var file = dir + \"/\" + files[i],\n        currFile = fs.lstatSync(file);\n\n    if(currFile.isDirectory()) { // Recursive function back to the beginning\n      rmdirSyncRecursive(file, force);\n    }\n\n    else if(currFile.isSymbolicLink()) { // Unlink symlinks\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          common.error('could not remove file (code '+e.code+'): ' + file, true);\n        }\n      }\n    }\n\n    else // Assume it's a file - perhaps a try/catch belongs here?\n      if (force || isWriteable(file)) {\n        try {\n          common.unlinkSync(file);\n        } catch (e) {\n          common.error('could not remove file (code '+e.code+'): ' + file, true);\n        }\n      }\n  }\n\n  // Now that we know everything in the sub-tree has been deleted, we can delete the main directory.\n  // Huzzah for the shopkeep.\n\n  var result;\n  try {\n    result = fs.rmdirSync(dir);\n  } catch(e) {\n    common.error('could not remove directory (code '+e.code+'): ' + dir, true);\n  }\n\n  return result;\n} // rmdirSyncRecursive\n\n// Hack to determine if file has write permissions for current user\n// Avoids having to check user, group, etc, but it's probably slow\nfunction isWriteable(file) {\n  var writePermission = true;\n  try {\n    var __fd = fs.openSync(file, 'a');\n    fs.closeSync(__fd);\n  } catch(e) {\n    writePermission = false;\n  }\n\n  return writePermission;\n}\n\n//@\n//@ ### rm([options ,] file [, file ...])\n//@ ### rm([options ,] file_array)\n//@ Available options:\n//@\n//@ + `-f`: force\n//@ + `-r, -R`: recursive\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ rm('-rf', '/tmp/*');\n//@ rm('some_file.txt', 'another_file.txt');\n//@ rm(['some_file.txt', 'another_file.txt']); // same as above\n//@ ```\n//@\n//@ Removes files. The wildcard `*` is accepted.\nfunction _rm(options, files) {\n  options = common.parseOptions(options, {\n    'f': 'force',\n    'r': 'recursive',\n    'R': 'recursive'\n  });\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  files.forEach(function(file) {\n    if (!fs.existsSync(file)) {\n      // Path does not exist, no force flag given\n      if (!options.force)\n        common.error('no such file or directory: '+file, true);\n\n      return; // skip file\n    }\n\n    // If here, path exists\n\n    var stats = fs.lstatSync(file);\n    if (stats.isFile() || stats.isSymbolicLink()) {\n\n      // Do not check for file writing permissions\n      if (options.force) {\n        common.unlinkSync(file);\n        return;\n      }\n\n      if (isWriteable(file))\n        common.unlinkSync(file);\n      else\n        common.error('permission denied: '+file, true);\n\n      return;\n    } // simple file\n\n    // Path is an existing directory, but no -r flag given\n    if (stats.isDirectory() && !options.recursive) {\n      common.error('path is a directory', true);\n      return; // skip path\n    }\n\n    // Recursively remove existing directory\n    if (stats.isDirectory() && options.recursive) {\n      rmdirSyncRecursive(file, options.force);\n    }\n  }); // forEach(file)\n} // rm\nmodule.exports = _rm;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/mv.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\n\n//@\n//@ ### mv(source [, source ...], dest')\n//@ ### mv(source_array, dest')\n//@ Available options:\n//@\n//@ + `f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mv('-f', 'file', 'dir/');\n//@ mv('file1', 'file2', 'dir/');\n//@ mv(['file1', 'file2'], 'dir/'); // same as above\n//@ ```\n//@\n//@ Moves files. The wildcard `*` is accepted.\nfunction _mv(options, sources, dest) {\n  options = common.parseOptions(options, {\n    'f': 'force'\n  });\n\n  // Get sources, dest\n  if (arguments.length < 3) {\n    common.error('missing <source> and/or <dest>');\n  } else if (arguments.length > 3) {\n    sources = [].slice.call(arguments, 1, arguments.length - 1);\n    dest = arguments[arguments.length - 1];\n  } else if (typeof sources === 'string') {\n    sources = [sources];\n  } else if ('length' in sources) {\n    sources = sources; // no-op for array\n  } else {\n    common.error('invalid arguments');\n  }\n\n  sources = common.expand(sources);\n\n  var exists = fs.existsSync(dest),\n      stats = exists && fs.statSync(dest);\n\n  // Dest is not existing dir, but multiple sources given\n  if ((!exists || !stats.isDirectory()) && sources.length > 1)\n    common.error('dest is not a directory (too many sources)');\n\n  // Dest is an existing file, but no -f given\n  if (exists && stats.isFile() && !options.force)\n    common.error('dest file already exists: ' + dest);\n\n  sources.forEach(function(src) {\n    if (!fs.existsSync(src)) {\n      common.error('no such file or directory: '+src, true);\n      return; // skip file\n    }\n\n    // If here, src exists\n\n    // When copying to '/path/dir':\n    //    thisDest = '/path/dir/file1'\n    var thisDest = dest;\n    if (fs.existsSync(dest) && fs.statSync(dest).isDirectory())\n      thisDest = path.normalize(dest + '/' + path.basename(src));\n\n    if (fs.existsSync(thisDest) && !options.force) {\n      common.error('dest file already exists: ' + thisDest, true);\n      return; // skip file\n    }\n\n    if (path.resolve(src) === path.dirname(path.resolve(thisDest))) {\n      common.error('cannot move to self: '+src, true);\n      return; // skip file\n    }\n\n    fs.renameSync(src, thisDest);\n  }); // forEach(src)\n} // mv\nmodule.exports = _mv;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/mkdir.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n// Recursively creates 'dir'\nfunction mkdirSyncRecursive(dir) {\n  var baseDir = path.dirname(dir);\n\n  // Base dir exists, no recursion necessary\n  if (fs.existsSync(baseDir)) {\n    fs.mkdirSync(dir, parseInt('0777', 8));\n    return;\n  }\n\n  // Base dir does not exist, go recursive\n  mkdirSyncRecursive(baseDir);\n\n  // Base dir created, can create dir\n  fs.mkdirSync(dir, parseInt('0777', 8));\n}\n\n//@\n//@ ### mkdir([options ,] dir [, dir ...])\n//@ ### mkdir([options ,] dir_array)\n//@ Available options:\n//@\n//@ + `p`: full path (will create intermediate dirs if necessary)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ mkdir('-p', '/tmp/a/b/c/d', '/tmp/e/f/g');\n//@ mkdir('-p', ['/tmp/a/b/c/d', '/tmp/e/f/g']); // same as above\n//@ ```\n//@\n//@ Creates directories.\nfunction _mkdir(options, dirs) {\n  options = common.parseOptions(options, {\n    'p': 'fullpath'\n  });\n  if (!dirs)\n    common.error('no paths given');\n\n  if (typeof dirs === 'string')\n    dirs = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  dirs.forEach(function(dir) {\n    if (fs.existsSync(dir)) {\n      if (!options.fullpath)\n          common.error('path already exists: ' + dir, true);\n      return; // skip dir\n    }\n\n    // Base dir does not exist, and no -p option given\n    var baseDir = path.dirname(dir);\n    if (!fs.existsSync(baseDir) && !options.fullpath) {\n      common.error('no such file or directory: ' + baseDir, true);\n      return; // skip dir\n    }\n\n    if (options.fullpath)\n      mkdirSyncRecursive(dir);\n    else\n      fs.mkdirSync(dir, parseInt('0777', 8));\n  });\n} // mkdir\nmodule.exports = _mkdir;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/test.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### test(expression)\n//@ Available expression primaries:\n//@\n//@ + `'-b', 'path'`: true if path is a block device\n//@ + `'-c', 'path'`: true if path is a character device\n//@ + `'-d', 'path'`: true if path is a directory\n//@ + `'-e', 'path'`: true if path exists\n//@ + `'-f', 'path'`: true if path is a regular file\n//@ + `'-L', 'path'`: true if path is a symboilc link\n//@ + `'-p', 'path'`: true if path is a pipe (FIFO)\n//@ + `'-S', 'path'`: true if path is a socket\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ if (test('-d', path)) { /* do something with dir */ };\n//@ if (!test('-f', path)) continue; // skip if it's a regular file\n//@ ```\n//@\n//@ Evaluates expression using the available primaries and returns corresponding value.\nfunction _test(options, path) {\n  if (!path)\n    common.error('no path given');\n\n  // hack - only works with unary primaries\n  options = common.parseOptions(options, {\n    'b': 'block',\n    'c': 'character',\n    'd': 'directory',\n    'e': 'exists',\n    'f': 'file',\n    'L': 'link',\n    'p': 'pipe',\n    'S': 'socket'\n  });\n\n  var canInterpret = false;\n  for (var key in options)\n    if (options[key] === true) {\n      canInterpret = true;\n      break;\n    }\n\n  if (!canInterpret)\n    common.error('could not interpret expression');\n\n  if (options.link) {\n    try {\n      return fs.lstatSync(path).isSymbolicLink();\n    } catch(e) {\n      return false;\n    }\n  }\n\n  if (!fs.existsSync(path))\n    return false;\n\n  if (options.exists)\n    return true;\n\n  var stats = fs.statSync(path);\n\n  if (options.block)\n    return stats.isBlockDevice();\n\n  if (options.character)\n    return stats.isCharacterDevice();\n\n  if (options.directory)\n    return stats.isDirectory();\n\n  if (options.file)\n    return stats.isFile();\n\n  if (options.pipe)\n    return stats.isFIFO();\n\n  if (options.socket)\n    return stats.isSocket();\n} // test\nmodule.exports = _test;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/cat.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### cat(file [, file ...])\n//@ ### cat(file_array)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var str = cat('file*.txt');\n//@ var str = cat('file1', 'file2');\n//@ var str = cat(['file1', 'file2']); // same as above\n//@ ```\n//@\n//@ Returns a string containing the given file, or a concatenated string\n//@ containing the files if more than one file is given (a new line character is\n//@ introduced between each file). Wildcard `*` accepted.\nfunction _cat(options, files) {\n  var cat = '';\n\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 1);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  files.forEach(function(file) {\n    if (!fs.existsSync(file))\n      common.error('no such file or directory: ' + file);\n\n    cat += fs.readFileSync(file, 'utf8') + '\\n';\n  });\n\n  if (cat[cat.length-1] === '\\n')\n    cat = cat.substring(0, cat.length-1);\n\n  return common.ShellString(cat);\n}\nmodule.exports = _cat;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/to.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n//@\n//@ ### 'string'.to(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').to('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirection operator `>` in Unix, but works with JavaScript strings (such as\n//@ those returned by `cat`, `grep`, etc). _Like Unix redirections, `to()` will overwrite any existing file!_\nfunction _to(options, file) {\n  if (!file)\n    common.error('wrong arguments');\n\n  if (!fs.existsSync( path.dirname(file) ))\n      common.error('no such file or directory: ' + path.dirname(file));\n\n  try {\n    fs.writeFileSync(file, this.toString(), 'utf8');\n  } catch(e) {\n    common.error('could not write to file (code '+e.code+'): '+file, true);\n  }\n}\nmodule.exports = _to;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/toEnd.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n//@\n//@ ### 'string'.toEnd(file)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ cat('input.txt').toEnd('output.txt');\n//@ ```\n//@\n//@ Analogous to the redirect-and-append operator `>>` in Unix, but works with JavaScript strings (such as\n//@ those returned by `cat`, `grep`, etc).\nfunction _toEnd(options, file) {\n  if (!file)\n    common.error('wrong arguments');\n\n  if (!fs.existsSync( path.dirname(file) ))\n      common.error('no such file or directory: ' + path.dirname(file));\n\n  try {\n    fs.appendFileSync(file, this.toString(), 'utf8');\n  } catch(e) {\n    common.error('could not append to file (code '+e.code+'): '+file, true);\n  }\n}\nmodule.exports = _toEnd;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/sed.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### sed([options ,] search_regex, replacement, file)\n//@ Available options:\n//@\n//@ + `-i`: Replace contents of 'file' in-place. _Note that no backups will be created!_\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ sed('-i', 'PROGRAM_VERSION', 'v0.1.3', 'source.js');\n//@ sed(/.*DELETE_THIS_LINE.*\\n/, '', 'source.js');\n//@ ```\n//@\n//@ Reads an input string from `file` and performs a JavaScript `replace()` on the input\n//@ using the given search regex and replacement string or function. Returns the new string after replacement.\nfunction _sed(options, regex, replacement, file) {\n  options = common.parseOptions(options, {\n    'i': 'inplace'\n  });\n\n  if (typeof replacement === 'string' || typeof replacement === 'function')\n    replacement = replacement; // no-op\n  else if (typeof replacement === 'number')\n    replacement = replacement.toString(); // fallback\n  else\n    common.error('invalid replacement string');\n\n  if (!file)\n    common.error('no file given');\n\n  if (!fs.existsSync(file))\n    common.error('no such file or directory: ' + file);\n\n  var result = fs.readFileSync(file, 'utf8').replace(regex, replacement);\n  if (options.inplace)\n    fs.writeFileSync(file, result, 'utf8');\n\n  return common.ShellString(result);\n}\nmodule.exports = _sed;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/grep.js":"var common = require('./common');\nvar fs = require('fs');\n\n//@\n//@ ### grep([options ,] regex_filter, file [, file ...])\n//@ ### grep([options ,] regex_filter, file_array)\n//@ Available options:\n//@\n//@ + `-v`: Inverse the sense of the regex and print the lines not matching the criteria.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ grep('-v', 'GLOBAL_VARIABLE', '*.js');\n//@ grep('GLOBAL_VARIABLE', '*.js');\n//@ ```\n//@\n//@ Reads input string from given files and returns a string containing all lines of the\n//@ file that match the given `regex_filter`. Wildcard `*` accepted.\nfunction _grep(options, regex, files) {\n  options = common.parseOptions(options, {\n    'v': 'inverse'\n  });\n\n  if (!files)\n    common.error('no paths given');\n\n  if (typeof files === 'string')\n    files = [].slice.call(arguments, 2);\n  // if it's array leave it as it is\n\n  files = common.expand(files);\n\n  var grep = '';\n  files.forEach(function(file) {\n    if (!fs.existsSync(file)) {\n      common.error('no such file or directory: ' + file, true);\n      return;\n    }\n\n    var contents = fs.readFileSync(file, 'utf8'),\n        lines = contents.split(/\\r*\\n/);\n    lines.forEach(function(line) {\n      var matched = line.match(regex);\n      if ((options.inverse && !matched) || (!options.inverse && matched))\n        grep += line + '\\n';\n    });\n  });\n\n  return common.ShellString(grep);\n}\nmodule.exports = _grep;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/which.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\n// Cross-platform method for splitting environment PATH variables\nfunction splitPath(p) {\n  for (i=1;i<2;i++) {}\n\n  if (!p)\n    return [];\n\n  if (common.platform === 'win')\n    return p.split(';');\n  else\n    return p.split(':');\n}\n\nfunction checkPath(path) {\n  return fs.existsSync(path) && fs.statSync(path).isDirectory() == false;\n}\n\n//@\n//@ ### which(command)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var nodeExec = which('node');\n//@ ```\n//@\n//@ Searches for `command` in the system's PATH. On Windows looks for `.exe`, `.cmd`, and `.bat` extensions.\n//@ Returns string containing the absolute path to the command.\nfunction _which(options, cmd) {\n  if (!cmd)\n    common.error('must specify command');\n\n  var pathEnv = process.env.path || process.env.Path || process.env.PATH,\n      pathArray = splitPath(pathEnv),\n      where = null;\n\n  // No relative/absolute paths provided?\n  if (cmd.search(/\\//) === -1) {\n    // Search for command in PATH\n    pathArray.forEach(function(dir) {\n      if (where)\n        return; // already found it\n\n      var attempt = path.resolve(dir + '/' + cmd);\n      if (checkPath(attempt)) {\n        where = attempt;\n        return;\n      }\n\n      if (common.platform === 'win') {\n        var baseAttempt = attempt;\n        attempt = baseAttempt + '.exe';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n        attempt = baseAttempt + '.cmd';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n        attempt = baseAttempt + '.bat';\n        if (checkPath(attempt)) {\n          where = attempt;\n          return;\n        }\n      } // if 'win'\n    });\n  }\n\n  // Command not found anywhere?\n  if (!checkPath(cmd) && !where)\n    return null;\n\n  where = where || path.resolve(cmd);\n\n  return common.ShellString(where);\n}\nmodule.exports = _which;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/echo.js":"var common = require('./common');\n\n//@\n//@ ### echo(string [,string ...])\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo('hello world');\n//@ var str = echo('hello world');\n//@ ```\n//@\n//@ Prints string to stdout, and returns string with additional utility methods\n//@ like `.to()`.\nfunction _echo() {\n  var messages = [].slice.call(arguments, 0);\n  console.log.apply(this, messages);\n  return common.ShellString(messages.join(' '));\n}\nmodule.exports = _echo;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/dirs.js":"var common = require('./common');\nvar _cd = require('./cd');\nvar path = require('path');\n\n// Pushd/popd/dirs internals\nvar _dirStack = [];\n\nfunction _isStackIndex(index) {\n  return (/^[\\-+]\\d+$/).test(index);\n}\n\nfunction _parseStackIndex(index) {\n  if (_isStackIndex(index)) {\n    if (Math.abs(index) < _dirStack.length + 1) { // +1 for pwd\n      return (/^-/).test(index) ? Number(index) - 1 : Number(index);\n    } else {\n      common.error(index + ': directory stack index out of range');\n    }\n  } else {\n    common.error(index + ': invalid number');\n  }\n}\n\nfunction _actualDirStack() {\n  return [process.cwd()].concat(_dirStack);\n}\n\n//@\n//@ ### pushd([options,] [dir | '-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when adding directories to the stack, so that only the stack is manipulated.\n//@\n//@ Arguments:\n//@\n//@ + `dir`: Makes the current working directory be the top of the stack, and then executes the equivalent of `cd dir`.\n//@ + `+N`: Brings the Nth directory (counting from the left of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@ + `-N`: Brings the Nth directory (counting from the right of the list printed by dirs, starting with zero) to the top of the list by rotating the stack.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ // process.cwd() === '/usr'\n//@ pushd('/etc'); // Returns /etc /usr\n//@ pushd('+1');   // Returns /usr /etc\n//@ ```\n//@\n//@ Save the current directory on the top of the directory stack and then cd to `dir`. With no arguments, pushd exchanges the top two directories. Returns an array of paths in the stack.\nfunction _pushd(options, dir) {\n  if (_isStackIndex(options)) {\n    dir = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n' : 'no-cd'\n  });\n\n  var dirs = _actualDirStack();\n\n  if (dir === '+0') {\n    return dirs; // +0 is a noop\n  } else if (!dir) {\n    if (dirs.length > 1) {\n      dirs = dirs.splice(1, 1).concat(dirs);\n    } else {\n      return common.error('no other directory');\n    }\n  } else if (_isStackIndex(dir)) {\n    var n = _parseStackIndex(dir);\n    dirs = dirs.slice(n).concat(dirs.slice(0, n));\n  } else {\n    if (options['no-cd']) {\n      dirs.splice(1, 0, dir);\n    } else {\n      dirs.unshift(dir);\n    }\n  }\n\n  if (options['no-cd']) {\n    dirs = dirs.slice(1);\n  } else {\n    dir = path.resolve(dirs.shift());\n    _cd('', dir);\n  }\n\n  _dirStack = dirs;\n  return _dirs('');\n}\nexports.pushd = _pushd;\n\n//@\n//@ ### popd([options,] ['-N' | '+N'])\n//@\n//@ Available options:\n//@\n//@ + `-n`: Suppresses the normal change of directory when removing directories from the stack, so that only the stack is manipulated.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Removes the Nth directory (counting from the left of the list printed by dirs), starting with zero.\n//@ + `-N`: Removes the Nth directory (counting from the right of the list printed by dirs), starting with zero.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo(process.cwd()); // '/usr'\n//@ pushd('/etc');       // '/etc /usr'\n//@ echo(process.cwd()); // '/etc'\n//@ popd();              // '/usr'\n//@ echo(process.cwd()); // '/usr'\n//@ ```\n//@\n//@ When no arguments are given, popd removes the top directory from the stack and performs a cd to the new top directory. The elements are numbered from 0 starting at the first directory listed with dirs; i.e., popd is equivalent to popd +0. Returns an array of paths in the stack.\nfunction _popd(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'n' : 'no-cd'\n  });\n\n  if (!_dirStack.length) {\n    return common.error('directory stack empty');\n  }\n\n  index = _parseStackIndex(index || '+0');\n\n  if (options['no-cd'] || index > 0 || _dirStack.length + index === 0) {\n    index = index > 0 ? index - 1 : index;\n    _dirStack.splice(index, 1);\n  } else {\n    var dir = path.resolve(_dirStack.shift());\n    _cd('', dir);\n  }\n\n  return _dirs('');\n}\nexports.popd = _popd;\n\n//@\n//@ ### dirs([options | '+N' | '-N'])\n//@\n//@ Available options:\n//@\n//@ + `-c`: Clears the directory stack by deleting all of the elements.\n//@\n//@ Arguments:\n//@\n//@ + `+N`: Displays the Nth directory (counting from the left of the list printed by dirs when invoked without options), starting with zero.\n//@ + `-N`: Displays the Nth directory (counting from the right of the list printed by dirs when invoked without options), starting with zero.\n//@\n//@ Display the list of currently remembered directories. Returns an array of paths in the stack, or a single path if +N or -N was specified.\n//@\n//@ See also: pushd, popd\nfunction _dirs(options, index) {\n  if (_isStackIndex(options)) {\n    index = options;\n    options = '';\n  }\n\n  options = common.parseOptions(options, {\n    'c' : 'clear'\n  });\n\n  if (options['clear']) {\n    _dirStack = [];\n    return _dirStack;\n  }\n\n  var stack = _actualDirStack();\n\n  if (index) {\n    index = _parseStackIndex(index);\n\n    if (index < 0) {\n      index = stack.length + index;\n    }\n\n    common.log(stack[index]);\n    return stack[index];\n  }\n\n  common.log(stack.join(' '));\n\n  return stack;\n}\nexports.dirs = _dirs;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/ln.js":"var fs = require('fs');\nvar path = require('path');\nvar common = require('./common');\nvar os = require('os');\n\n//@\n//@ ### ln(options, source, dest)\n//@ ### ln(source, dest)\n//@ Available options:\n//@\n//@ + `s`: symlink\n//@ + `f`: force\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ ln('file', 'newlink');\n//@ ln('-sf', 'file', 'existing');\n//@ ```\n//@\n//@ Links source to dest. Use -f to force the link, should dest already exist.\nfunction _ln(options, source, dest) {\n  options = common.parseOptions(options, {\n    's': 'symlink',\n    'f': 'force'\n  });\n\n  if (!source || !dest) {\n    common.error('Missing <source> and/or <dest>');\n  }\n\n  source = path.resolve(process.cwd(), String(source));\n  dest = path.resolve(process.cwd(), String(dest));\n\n  if (!fs.existsSync(source)) {\n    common.error('Source file does not exist', true);\n  }\n\n  if (fs.existsSync(dest)) {\n    if (!options.force) {\n      common.error('Destination file exists', true);\n    }\n\n    fs.unlinkSync(dest);\n  }\n\n  if (options.symlink) {\n    fs.symlinkSync(source, dest, os.platform() === \"win32\" ? \"junction\" : null);\n  } else {\n    fs.linkSync(source, dest, os.platform() === \"win32\" ? \"junction\" : null);\n  }\n}\nmodule.exports = _ln;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/exec.js":"var common = require('./common');\nvar _tempDir = require('./tempdir');\nvar _pwd = require('./pwd');\nvar path = require('path');\nvar fs = require('fs');\nvar child = require('child_process');\n\n// Hack to run child_process.exec() synchronously (sync avoids callback hell)\n// Uses a custom wait loop that checks for a flag file, created when the child process is done.\n// (Can't do a wait loop that checks for internal Node variables/messages as\n// Node is single-threaded; callbacks and other internal state changes are done in the\n// event loop).\nfunction execSync(cmd, opts) {\n  var tempDir = _tempDir();\n  var stdoutFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      codeFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      scriptFile = path.resolve(tempDir+'/'+common.randomFileName()),\n      sleepFile = path.resolve(tempDir+'/'+common.randomFileName());\n\n  var options = common.extend({\n    silent: common.config.silent\n  }, opts);\n\n  var previousStdoutContent = '';\n  // Echoes stdout changes from running process, if not silent\n  function updateStdout() {\n    if (options.silent || !fs.existsSync(stdoutFile))\n      return;\n\n    var stdoutContent = fs.readFileSync(stdoutFile, 'utf8');\n    // No changes since last time?\n    if (stdoutContent.length <= previousStdoutContent.length)\n      return;\n\n    process.stdout.write(stdoutContent.substr(previousStdoutContent.length));\n    previousStdoutContent = stdoutContent;\n  }\n\n  function escape(str) {\n    return (str+'').replace(/([\\\\\"'])/g, \"\\\\$1\").replace(/\\0/g, \"\\\\0\");\n  }\n\n  cmd += ' > '+stdoutFile+' 2>&1'; // works on both win/unix\n\n  var script =\n   \"var child = require('child_process'),\" +\n   \"     fs = require('fs');\" +\n   \"child.exec('\"+escape(cmd)+\"', {env: process.env, maxBuffer: 20*1024*1024}, function(err) {\" +\n   \"  fs.writeFileSync('\"+escape(codeFile)+\"', err ? err.code.toString() : '0');\" +\n   \"});\";\n\n  if (fs.existsSync(scriptFile)) common.unlinkSync(scriptFile);\n  if (fs.existsSync(stdoutFile)) common.unlinkSync(stdoutFile);\n  if (fs.existsSync(codeFile)) common.unlinkSync(codeFile);\n\n  fs.writeFileSync(scriptFile, script);\n  child.exec('\"'+process.execPath+'\" '+scriptFile, {\n    env: process.env,\n    cwd: _pwd(),\n    maxBuffer: 20*1024*1024\n  });\n\n  // The wait loop\n  // sleepFile is used as a dummy I/O op to mitigate unnecessary CPU usage\n  // (tried many I/O sync ops, writeFileSync() seems to be only one that is effective in reducing\n  // CPU usage, though apparently not so much on Windows)\n  while (!fs.existsSync(codeFile)) { updateStdout(); fs.writeFileSync(sleepFile, 'a'); }\n  while (!fs.existsSync(stdoutFile)) { updateStdout(); fs.writeFileSync(sleepFile, 'a'); }\n\n  // At this point codeFile exists, but it's not necessarily flushed yet.\n  // Keep reading it until it is.\n  var code = parseInt('', 10);\n  while (isNaN(code)) {\n    code = parseInt(fs.readFileSync(codeFile, 'utf8'), 10);\n  }\n\n  var stdout = fs.readFileSync(stdoutFile, 'utf8');\n\n  // No biggie if we can't erase the files now -- they're in a temp dir anyway\n  try { common.unlinkSync(scriptFile); } catch(e) {}\n  try { common.unlinkSync(stdoutFile); } catch(e) {}\n  try { common.unlinkSync(codeFile); } catch(e) {}\n  try { common.unlinkSync(sleepFile); } catch(e) {}\n\n  // some shell return codes are defined as errors, per http://tldp.org/LDP/abs/html/exitcodes.html\n  if (code === 1 || code === 2 || code >= 126)  {\n      common.error('', true); // unix/shell doesn't really give an error message after non-zero exit codes\n  }\n  // True if successful, false if not\n  var obj = {\n    code: code,\n    output: stdout\n  };\n  return obj;\n} // execSync()\n\n// Wrapper around exec() to enable echoing output to console in real time\nfunction execAsync(cmd, opts, callback) {\n  var output = '';\n\n  var options = common.extend({\n    silent: common.config.silent\n  }, opts);\n\n  var c = child.exec(cmd, {env: process.env, maxBuffer: 20*1024*1024}, function(err) {\n    if (callback)\n      callback(err ? err.code : 0, output);\n  });\n\n  c.stdout.on('data', function(data) {\n    output += data;\n    if (!options.silent)\n      process.stdout.write(data);\n  });\n\n  c.stderr.on('data', function(data) {\n    output += data;\n    if (!options.silent)\n      process.stdout.write(data);\n  });\n\n  return c;\n}\n\n//@\n//@ ### exec(command [, options] [, callback])\n//@ Available options (all `false` by default):\n//@\n//@ + `async`: Asynchronous execution. Defaults to true if a callback is provided.\n//@ + `silent`: Do not echo program output to console.\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var version = exec('node --version', {silent:true}).output;\n//@\n//@ var child = exec('some_long_running_process', {async:true});\n//@ child.stdout.on('data', function(data) {\n//@   /* ... do something with data ... */\n//@ });\n//@\n//@ exec('some_long_running_process', function(code, output) {\n//@   console.log('Exit code:', code);\n//@   console.log('Program output:', output);\n//@ });\n//@ ```\n//@\n//@ Executes the given `command` _synchronously_, unless otherwise specified.\n//@ When in synchronous mode returns the object `{ code:..., output:... }`, containing the program's\n//@ `output` (stdout + stderr)  and its exit `code`. Otherwise returns the child process object, and\n//@ the `callback` gets the arguments `(code, output)`.\n//@\n//@ **Note:** For long-lived processes, it's best to run `exec()` asynchronously as\n//@ the current synchronous implementation uses a lot of CPU. This should be getting\n//@ fixed soon.\nfunction _exec(command, options, callback) {\n  if (!command)\n    common.error('must specify command');\n\n  // Callback is defined instead of options.\n  if (typeof options === 'function') {\n    callback = options;\n    options = { async: true };\n  }\n\n  // Callback is defined with options.\n  if (typeof options === 'object' && typeof callback === 'function') {\n    options.async = true;\n  }\n\n  options = common.extend({\n    silent: common.config.silent,\n    async: false\n  }, options);\n\n  if (options.async)\n    return execAsync(command, options, callback);\n  else\n    return execSync(command, options);\n}\nmodule.exports = _exec;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/tempdir.js":"var common = require('./common');\nvar os = require('os');\nvar fs = require('fs');\n\n// Returns false if 'dir' is not a writeable directory, 'dir' otherwise\nfunction writeableDir(dir) {\n  if (!dir || !fs.existsSync(dir))\n    return false;\n\n  if (!fs.statSync(dir).isDirectory())\n    return false;\n\n  var testFile = dir+'/'+common.randomFileName();\n  try {\n    fs.writeFileSync(testFile, ' ');\n    common.unlinkSync(testFile);\n    return dir;\n  } catch (e) {\n    return false;\n  }\n}\n\n\n//@\n//@ ### tempdir()\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var tmp = tempdir(); // \"/tmp\" for most *nix platforms\n//@ ```\n//@\n//@ Searches and returns string containing a writeable, platform-dependent temporary directory.\n//@ Follows Python's [tempfile algorithm](http://docs.python.org/library/tempfile.html#tempfile.tempdir).\nfunction _tempDir() {\n  var state = common.state;\n  if (state.tempDir)\n    return state.tempDir; // from cache\n\n  state.tempDir = writeableDir(os.tempDir && os.tempDir()) || // node 0.8+\n                  writeableDir(process.env['TMPDIR']) ||\n                  writeableDir(process.env['TEMP']) ||\n                  writeableDir(process.env['TMP']) ||\n                  writeableDir(process.env['Wimp$ScrapDir']) || // RiscOS\n                  writeableDir('C:\\\\TEMP') || // Windows\n                  writeableDir('C:\\\\TMP') || // Windows\n                  writeableDir('\\\\TEMP') || // Windows\n                  writeableDir('\\\\TMP') || // Windows\n                  writeableDir('/tmp') ||\n                  writeableDir('/var/tmp') ||\n                  writeableDir('/usr/tmp') ||\n                  writeableDir('.'); // last resort\n\n  return state.tempDir;\n}\nmodule.exports = _tempDir;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/chmod.js":"var common = require('./common');\nvar fs = require('fs');\nvar path = require('path');\n\nvar PERMS = (function (base) {\n  return {\n    OTHER_EXEC  : base.EXEC,\n    OTHER_WRITE : base.WRITE,\n    OTHER_READ  : base.READ,\n\n    GROUP_EXEC  : base.EXEC  << 3,\n    GROUP_WRITE : base.WRITE << 3,\n    GROUP_READ  : base.READ << 3,\n\n    OWNER_EXEC  : base.EXEC << 6,\n    OWNER_WRITE : base.WRITE << 6,\n    OWNER_READ  : base.READ << 6,\n\n    // Literal octal numbers are apparently not allowed in \"strict\" javascript.  Using parseInt is\n    // the preferred way, else a jshint warning is thrown.\n    STICKY      : parseInt('01000', 8),\n    SETGID      : parseInt('02000', 8),\n    SETUID      : parseInt('04000', 8),\n\n    TYPE_MASK   : parseInt('0770000', 8)\n  };\n})({\n  EXEC  : 1,\n  WRITE : 2,\n  READ  : 4\n});\n\n//@\n//@ ### chmod(octal_mode || octal_string, file)\n//@ ### chmod(symbolic_mode, file)\n//@\n//@ Available options:\n//@\n//@ + `-v`: output a diagnostic for every file processed//@\n//@ + `-c`: like verbose but report only when a change is made//@\n//@ + `-R`: change files and directories recursively//@\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ chmod(755, '/Users/brandon');\n//@ chmod('755', '/Users/brandon'); // same as above\n//@ chmod('u+x', '/Users/brandon');\n//@ ```\n//@\n//@ Alters the permissions of a file or directory by either specifying the\n//@ absolute permissions in octal form or expressing the changes in symbols.\n//@ This command tries to mimic the POSIX behavior as much as possible.\n//@ Notable exceptions:\n//@\n//@ + In symbolic modes, 'a-r' and '-r' are identical.  No consideration is\n//@   given to the umask.\n//@ + There is no \"quiet\" option since default behavior is to run silent.\nfunction _chmod(options, mode, filePattern) {\n  if (!filePattern) {\n    if (options.length > 0 && options.charAt(0) === '-') {\n      // Special case where the specified file permissions started with - to subtract perms, which\n      // get picked up by the option parser as command flags.\n      // If we are down by one argument and options starts with -, shift everything over.\n      filePattern = mode;\n      mode = options;\n      options = '';\n    }\n    else {\n      common.error('You must specify a file.');\n    }\n  }\n\n  options = common.parseOptions(options, {\n    'R': 'recursive',\n    'c': 'changes',\n    'v': 'verbose'\n  });\n\n  if (typeof filePattern === 'string') {\n    filePattern = [ filePattern ];\n  }\n\n  var files;\n\n  if (options.recursive) {\n    files = [];\n    common.expand(filePattern).forEach(function addFile(expandedFile) {\n      var stat = fs.lstatSync(expandedFile);\n\n      if (!stat.isSymbolicLink()) {\n        files.push(expandedFile);\n\n        if (stat.isDirectory()) {  // intentionally does not follow symlinks.\n          fs.readdirSync(expandedFile).forEach(function (child) {\n            addFile(expandedFile + '/' + child);\n          });\n        }\n      }\n    });\n  }\n  else {\n    files = common.expand(filePattern);\n  }\n\n  files.forEach(function innerChmod(file) {\n    file = path.resolve(file);\n    if (!fs.existsSync(file)) {\n      common.error('File not found: ' + file);\n    }\n\n    // When recursing, don't follow symlinks.\n    if (options.recursive && fs.lstatSync(file).isSymbolicLink()) {\n      return;\n    }\n\n    var perms = fs.statSync(file).mode;\n    var type = perms & PERMS.TYPE_MASK;\n\n    var newPerms = perms;\n\n    if (isNaN(parseInt(mode, 8))) {\n      // parse options\n      mode.split(',').forEach(function (symbolicMode) {\n        /*jshint regexdash:true */\n        var pattern = /([ugoa]*)([=\\+-])([rwxXst]*)/i;\n        var matches = pattern.exec(symbolicMode);\n\n        if (matches) {\n          var applyTo = matches[1];\n          var operator = matches[2];\n          var change = matches[3];\n\n          var changeOwner = applyTo.indexOf('u') != -1 || applyTo === 'a' || applyTo === '';\n          var changeGroup = applyTo.indexOf('g') != -1 || applyTo === 'a' || applyTo === '';\n          var changeOther = applyTo.indexOf('o') != -1 || applyTo === 'a' || applyTo === '';\n\n          var changeRead   = change.indexOf('r') != -1;\n          var changeWrite  = change.indexOf('w') != -1;\n          var changeExec   = change.indexOf('x') != -1;\n          var changeSticky = change.indexOf('t') != -1;\n          var changeSetuid = change.indexOf('s') != -1;\n\n          var mask = 0;\n          if (changeOwner) {\n            mask |= (changeRead ? PERMS.OWNER_READ : 0) + (changeWrite ? PERMS.OWNER_WRITE : 0) + (changeExec ? PERMS.OWNER_EXEC : 0) + (changeSetuid ? PERMS.SETUID : 0);\n          }\n          if (changeGroup) {\n            mask |= (changeRead ? PERMS.GROUP_READ : 0) + (changeWrite ? PERMS.GROUP_WRITE : 0) + (changeExec ? PERMS.GROUP_EXEC : 0) + (changeSetuid ? PERMS.SETGID : 0);\n          }\n          if (changeOther) {\n            mask |= (changeRead ? PERMS.OTHER_READ : 0) + (changeWrite ? PERMS.OTHER_WRITE : 0) + (changeExec ? PERMS.OTHER_EXEC : 0);\n          }\n\n          // Sticky bit is special - it's not tied to user, group or other.\n          if (changeSticky) {\n            mask |= PERMS.STICKY;\n          }\n\n          switch (operator) {\n            case '+':\n              newPerms |= mask;\n              break;\n\n            case '-':\n              newPerms &= ~mask;\n              break;\n\n            case '=':\n              newPerms = type + mask;\n\n              // According to POSIX, when using = to explicitly set the permissions, setuid and setgid can never be cleared.\n              if (fs.statSync(file).isDirectory()) {\n                newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n              }\n              break;\n          }\n\n          if (options.verbose) {\n            log(file + ' -> ' + newPerms.toString(8));\n          }\n\n          if (perms != newPerms) {\n            if (!options.verbose && options.changes) {\n              log(file + ' -> ' + newPerms.toString(8));\n            }\n            fs.chmodSync(file, newPerms);\n          }\n        }\n        else {\n          common.error('Invalid symbolic mode change: ' + symbolicMode);\n        }\n      });\n    }\n    else {\n      // they gave us a full number\n      newPerms = type + parseInt(mode, 8);\n\n      // POSIX rules are that setuid and setgid can only be added using numeric form, but not cleared.\n      if (fs.statSync(file).isDirectory()) {\n        newPerms |= (PERMS.SETUID + PERMS.SETGID) & perms;\n      }\n\n      fs.chmodSync(file, newPerms);\n    }\n  });\n}\nmodule.exports = _chmod;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/shelljs/src/error.js":"var common = require('./common');\n\n//@\n//@ ### error()\n//@ Tests if error occurred in the last command. Returns `null` if no error occurred,\n//@ otherwise returns string explaining the error\nfunction error() {\n  return common.state.error;\n};\nmodule.exports = error;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/nopt/lib/nopt.js":"// info about each config option.\n\nvar debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG\n  ? function () { console.error.apply(console, arguments) }\n  : function () {}\n\nvar url = require(\"url\")\n  , path = require(\"path\")\n  , Stream = require(\"stream\").Stream\n  , abbrev = require(\"abbrev\")\n\nmodule.exports = exports = nopt\nexports.clean = clean\n\nexports.typeDefs =\n  { String  : { type: String,  validate: validateString  }\n  , Boolean : { type: Boolean, validate: validateBoolean }\n  , url     : { type: url,     validate: validateUrl     }\n  , Number  : { type: Number,  validate: validateNumber  }\n  , path    : { type: path,    validate: validatePath    }\n  , Stream  : { type: Stream,  validate: validateStream  }\n  , Date    : { type: Date,    validate: validateDate    }\n  }\n\nfunction nopt (types, shorthands, args, slice) {\n  args = args || process.argv\n  types = types || {}\n  shorthands = shorthands || {}\n  if (typeof slice !== \"number\") slice = 2\n\n  debug(types, shorthands, args, slice)\n\n  args = args.slice(slice)\n  var data = {}\n    , key\n    , remain = []\n    , cooked = args\n    , original = args.slice(0)\n\n  parse(args, data, remain, types, shorthands)\n  // now data is full\n  clean(data, types, exports.typeDefs)\n  data.argv = {remain:remain,cooked:cooked,original:original}\n  Object.defineProperty(data.argv, 'toString', { value: function () {\n    return this.original.map(JSON.stringify).join(\" \")\n  }, enumerable: false })\n  return data\n}\n\nfunction clean (data, types, typeDefs) {\n  typeDefs = typeDefs || exports.typeDefs\n  var remove = {}\n    , typeDefault = [false, true, null, String, Array]\n\n  Object.keys(data).forEach(function (k) {\n    if (k === \"argv\") return\n    var val = data[k]\n      , isArray = Array.isArray(val)\n      , type = types[k]\n    if (!isArray) val = [val]\n    if (!type) type = typeDefault\n    if (type === Array) type = typeDefault.concat(Array)\n    if (!Array.isArray(type)) type = [type]\n\n    debug(\"val=%j\", val)\n    debug(\"types=\", type)\n    val = val.map(function (val) {\n      // if it's an unknown value, then parse false/true/null/numbers/dates\n      if (typeof val === \"string\") {\n        debug(\"string %j\", val)\n        val = val.trim()\n        if ((val === \"null\" && ~type.indexOf(null))\n            || (val === \"true\" &&\n               (~type.indexOf(true) || ~type.indexOf(Boolean)))\n            || (val === \"false\" &&\n               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {\n          val = JSON.parse(val)\n          debug(\"jsonable %j\", val)\n        } else if (~type.indexOf(Number) && !isNaN(val)) {\n          debug(\"convert to number\", val)\n          val = +val\n        } else if (~type.indexOf(Date) && !isNaN(Date.parse(val))) {\n          debug(\"convert to date\", val)\n          val = new Date(val)\n        }\n      }\n\n      if (!types.hasOwnProperty(k)) {\n        return val\n      }\n\n      // allow `--no-blah` to set 'blah' to null if null is allowed\n      if (val === false && ~type.indexOf(null) &&\n          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {\n        val = null\n      }\n\n      var d = {}\n      d[k] = val\n      debug(\"prevalidated val\", d, val, types[k])\n      if (!validate(d, k, val, types[k], typeDefs)) {\n        if (exports.invalidHandler) {\n          exports.invalidHandler(k, val, types[k], data)\n        } else if (exports.invalidHandler !== false) {\n          debug(\"invalid: \"+k+\"=\"+val, types[k])\n        }\n        return remove\n      }\n      debug(\"validated val\", d, val, types[k])\n      return d[k]\n    }).filter(function (val) { return val !== remove })\n\n    if (!val.length) delete data[k]\n    else if (isArray) {\n      debug(isArray, data[k], val)\n      data[k] = val\n    } else data[k] = val[0]\n\n    debug(\"k=%s val=%j\", k, val, data[k])\n  })\n}\n\nfunction validateString (data, k, val) {\n  data[k] = String(val)\n}\n\nfunction validatePath (data, k, val) {\n  if (val === true) return false\n  if (val === null) return true\n\n  val = String(val)\n  var homePattern = process.platform === 'win32' ? /^~(\\/|\\\\)/ : /^~\\//\n  if (val.match(homePattern) && process.env.HOME) {\n    val = path.resolve(process.env.HOME, val.substr(2))\n  }\n  data[k] = path.resolve(String(val))\n  return true\n}\n\nfunction validateNumber (data, k, val) {\n  debug(\"validate Number %j %j %j\", k, val, isNaN(val))\n  if (isNaN(val)) return false\n  data[k] = +val\n}\n\nfunction validateDate (data, k, val) {\n  debug(\"validate Date %j %j %j\", k, val, Date.parse(val))\n  var s = Date.parse(val)\n  if (isNaN(s)) return false\n  data[k] = new Date(val)\n}\n\nfunction validateBoolean (data, k, val) {\n  if (val instanceof Boolean) val = val.valueOf()\n  else if (typeof val === \"string\") {\n    if (!isNaN(val)) val = !!(+val)\n    else if (val === \"null\" || val === \"false\") val = false\n    else val = true\n  } else val = !!val\n  data[k] = val\n}\n\nfunction validateUrl (data, k, val) {\n  val = url.parse(String(val))\n  if (!val.host) return false\n  data[k] = val.href\n}\n\nfunction validateStream (data, k, val) {\n  if (!(val instanceof Stream)) return false\n  data[k] = val\n}\n\nfunction validate (data, k, val, type, typeDefs) {\n  // arrays are lists of types.\n  if (Array.isArray(type)) {\n    for (var i = 0, l = type.length; i < l; i ++) {\n      if (type[i] === Array) continue\n      if (validate(data, k, val, type[i], typeDefs)) return true\n    }\n    delete data[k]\n    return false\n  }\n\n  // an array of anything?\n  if (type === Array) return true\n\n  // NaN is poisonous.  Means that something is not allowed.\n  if (type !== type) {\n    debug(\"Poison NaN\", k, val, type)\n    delete data[k]\n    return false\n  }\n\n  // explicit list of values\n  if (val === type) {\n    debug(\"Explicitly allowed %j\", val)\n    // if (isArray) (data[k] = data[k] || []).push(val)\n    // else data[k] = val\n    data[k] = val\n    return true\n  }\n\n  // now go through the list of typeDefs, validate against each one.\n  var ok = false\n    , types = Object.keys(typeDefs)\n  for (var i = 0, l = types.length; i < l; i ++) {\n    debug(\"test type %j %j %j\", k, val, types[i])\n    var t = typeDefs[types[i]]\n    if (t &&\n      ((type && type.name && t.type && t.type.name) ? (type.name === t.type.name) : (type === t.type))) {\n      var d = {}\n      ok = false !== t.validate(d, k, val)\n      val = d[k]\n      if (ok) {\n        // if (isArray) (data[k] = data[k] || []).push(val)\n        // else data[k] = val\n        data[k] = val\n        break\n      }\n    }\n  }\n  debug(\"OK? %j (%j %j %j)\", ok, k, val, types[i])\n\n  if (!ok) delete data[k]\n  return ok\n}\n\nfunction parse (args, data, remain, types, shorthands) {\n  debug(\"parse\", args, data, remain)\n\n  var key = null\n    , abbrevs = abbrev(Object.keys(types))\n    , shortAbbr = abbrev(Object.keys(shorthands))\n\n  for (var i = 0; i < args.length; i ++) {\n    var arg = args[i]\n    debug(\"arg\", arg)\n\n    if (arg.match(/^-{2,}$/)) {\n      // done with keys.\n      // the rest are args.\n      remain.push.apply(remain, args.slice(i + 1))\n      args[i] = \"--\"\n      break\n    }\n    var hadEq = false\n    if (arg.charAt(0) === \"-\" && arg.length > 1) {\n      if (arg.indexOf(\"=\") !== -1) {\n        hadEq = true\n        var v = arg.split(\"=\")\n        arg = v.shift()\n        v = v.join(\"=\")\n        args.splice.apply(args, [i, 1].concat([arg, v]))\n      }\n\n      // see if it's a shorthand\n      // if so, splice and back up to re-parse it.\n      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)\n      debug(\"arg=%j shRes=%j\", arg, shRes)\n      if (shRes) {\n        debug(arg, shRes)\n        args.splice.apply(args, [i, 1].concat(shRes))\n        if (arg !== shRes[0]) {\n          i --\n          continue\n        }\n      }\n      arg = arg.replace(/^-+/, \"\")\n      var no = null\n      while (arg.toLowerCase().indexOf(\"no-\") === 0) {\n        no = !no\n        arg = arg.substr(3)\n      }\n\n      if (abbrevs[arg]) arg = abbrevs[arg]\n\n      var isArray = types[arg] === Array ||\n        Array.isArray(types[arg]) && types[arg].indexOf(Array) !== -1\n\n      // allow unknown things to be arrays if specified multiple times.\n      if (!types.hasOwnProperty(arg) && data.hasOwnProperty(arg)) {\n        if (!Array.isArray(data[arg]))\n          data[arg] = [data[arg]]\n        isArray = true\n      }\n\n      var val\n        , la = args[i + 1]\n\n      var isBool = typeof no === 'boolean' ||\n        types[arg] === Boolean ||\n        Array.isArray(types[arg]) && types[arg].indexOf(Boolean) !== -1 ||\n        (typeof types[arg] === 'undefined' && !hadEq) ||\n        (la === \"false\" &&\n         (types[arg] === null ||\n          Array.isArray(types[arg]) && ~types[arg].indexOf(null)))\n\n      if (isBool) {\n        // just set and move along\n        val = !no\n        // however, also support --bool true or --bool false\n        if (la === \"true\" || la === \"false\") {\n          val = JSON.parse(la)\n          la = null\n          if (no) val = !val\n          i ++\n        }\n\n        // also support \"foo\":[Boolean, \"bar\"] and \"--foo bar\"\n        if (Array.isArray(types[arg]) && la) {\n          if (~types[arg].indexOf(la)) {\n            // an explicit type\n            val = la\n            i ++\n          } else if ( la === \"null\" && ~types[arg].indexOf(null) ) {\n            // null allowed\n            val = null\n            i ++\n          } else if ( !la.match(/^-{2,}[^-]/) &&\n                      !isNaN(la) &&\n                      ~types[arg].indexOf(Number) ) {\n            // number\n            val = +la\n            i ++\n          } else if ( !la.match(/^-[^-]/) && ~types[arg].indexOf(String) ) {\n            // string\n            val = la\n            i ++\n          }\n        }\n\n        if (isArray) (data[arg] = data[arg] || []).push(val)\n        else data[arg] = val\n\n        continue\n      }\n\n      if (types[arg] === String && la === undefined)\n        la = \"\"\n\n      if (la && la.match(/^-{2,}$/)) {\n        la = undefined\n        i --\n      }\n\n      val = la === undefined ? true : la\n      if (isArray) (data[arg] = data[arg] || []).push(val)\n      else data[arg] = val\n\n      i ++\n      continue\n    }\n    remain.push(arg)\n  }\n}\n\nfunction resolveShort (arg, shorthands, shortAbbr, abbrevs) {\n  // handle single-char shorthands glommed together, like\n  // npm ls -glp, but only if there is one dash, and only if\n  // all of the chars are single-char shorthands, and it's\n  // not a match to some other abbrev.\n  arg = arg.replace(/^-+/, '')\n\n  // if it's an exact known option, then don't go any further\n  if (abbrevs[arg] === arg)\n    return null\n\n  // if it's an exact known shortopt, same deal\n  if (shorthands[arg]) {\n    // make it an array, if it's a list of words\n    if (shorthands[arg] && !Array.isArray(shorthands[arg]))\n      shorthands[arg] = shorthands[arg].split(/\\s+/)\n\n    return shorthands[arg]\n  }\n\n  // first check to see if this arg is a set of single-char shorthands\n  var singles = shorthands.___singles\n  if (!singles) {\n    singles = Object.keys(shorthands).filter(function (s) {\n      return s.length === 1\n    }).reduce(function (l,r) {\n      l[r] = true\n      return l\n    }, {})\n    shorthands.___singles = singles\n    debug('shorthand singles', singles)\n  }\n\n  var chrs = arg.split(\"\").filter(function (c) {\n    return singles[c]\n  })\n\n  if (chrs.join(\"\") === arg) return chrs.map(function (c) {\n    return shorthands[c]\n  }).reduce(function (l, r) {\n    return l.concat(r)\n  }, [])\n\n\n  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg\n  if (abbrevs[arg] && !shorthands[arg])\n    return null\n\n  // if it's an abbr for a shorthand, then use that\n  if (shortAbbr[arg])\n    arg = shortAbbr[arg]\n\n  // make it an array, if it's a list of words\n  if (shorthands[arg] && !Array.isArray(shorthands[arg]))\n    shorthands[arg] = shorthands[arg].split(/\\s+/)\n\n  return shorthands[arg]\n}\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-lib/node_modules/semver/semver.js":"// export the class if we are in a Node-like system.\nif (typeof module === 'object' && module.exports === exports)\n  exports = module.exports = SemVer;\n\n// The debug function is excluded entirely from the minified version.\n/* nomin */ var debug;\n/* nomin */ if (typeof process === 'object' &&\n    /* nomin */ process.env &&\n    /* nomin */ process.env.NODE_DEBUG &&\n    /* nomin */ /\\bsemver\\b/i.test(process.env.NODE_DEBUG))\n  /* nomin */ debug = function() {\n    /* nomin */ var args = Array.prototype.slice.call(arguments, 0);\n    /* nomin */ args.unshift('SEMVER');\n    /* nomin */ console.log.apply(console, args);\n    /* nomin */ };\n/* nomin */ else\n  /* nomin */ debug = function() {};\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0';\n\nvar MAX_LENGTH = 256;\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\n// The actual regexps go on exports.re\nvar re = exports.re = [];\nvar src = exports.src = [];\nvar R = 0;\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++;\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\nvar NUMERICIDENTIFIERLOOSE = R++;\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\n\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++;\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\n\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++;\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')';\n\nvar MAINVERSIONLOOSE = R++;\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++;\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\n\nvar PRERELEASEIDENTIFIERLOOSE = R++;\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\n\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++;\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\n\nvar PRERELEASELOOSE = R++;\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++;\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++;\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\n\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++;\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?';\n\nsrc[FULL] = '^' + FULLPLAIN + '$';\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?';\n\nvar LOOSE = R++;\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\n\nvar GTLT = R++;\nsrc[GTLT] = '((?:<|>)?=?)';\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++;\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\nvar XRANGEIDENTIFIER = R++;\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\n\nvar XRANGEPLAIN = R++;\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?';\n\nvar XRANGEPLAINLOOSE = R++;\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?';\n\nvar XRANGE = R++;\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\nvar XRANGELOOSE = R++;\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++;\nsrc[LONETILDE] = '(?:~>?)';\n\nvar TILDETRIM = R++;\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\nvar tildeTrimReplace = '$1~';\n\nvar TILDE = R++;\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\nvar TILDELOOSE = R++;\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++;\nsrc[LONECARET] = '(?:\\\\^)';\n\nvar CARETTRIM = R++;\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\nvar caretTrimReplace = '$1^';\n\nvar CARET = R++;\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\nvar CARETLOOSE = R++;\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++;\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\nvar COMPARATOR = R++;\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\n\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++;\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\nvar comparatorTrimReplace = '$1$2$3';\n\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++;\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$';\n\nvar HYPHENRANGELOOSE = R++;\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$';\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++;\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i]);\n  if (!re[i])\n    re[i] = new RegExp(src[i]);\n}\n\nexports.parse = parse;\nfunction parse(version, loose) {\n  if (version instanceof SemVer)\n    return version;\n\n  if (typeof version !== 'string')\n    return null;\n\n  if (version.length > MAX_LENGTH)\n    return null;\n\n  var r = loose ? re[LOOSE] : re[FULL];\n  if (!r.test(version))\n    return null;\n\n  try {\n    return new SemVer(version, loose);\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.valid = valid;\nfunction valid(version, loose) {\n  var v = parse(version, loose);\n  return v ? v.version : null;\n}\n\n\nexports.clean = clean;\nfunction clean(version, loose) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), loose);\n  return s ? s.version : null;\n}\n\nexports.SemVer = SemVer;\n\nfunction SemVer(version, loose) {\n  if (version instanceof SemVer) {\n    if (version.loose === loose)\n      return version;\n    else\n      version = version.version;\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version);\n  }\n\n  if (version.length > MAX_LENGTH)\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n\n  if (!(this instanceof SemVer))\n    return new SemVer(version, loose);\n\n  debug('SemVer', version, loose);\n  this.loose = loose;\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\n\n  if (!m)\n    throw new TypeError('Invalid Version: ' + version);\n\n  this.raw = version;\n\n  // these are actually numbers\n  this.major = +m[1];\n  this.minor = +m[2];\n  this.patch = +m[3];\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0)\n    throw new TypeError('Invalid major version')\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0)\n    throw new TypeError('Invalid minor version')\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0)\n    throw new TypeError('Invalid patch version')\n\n  // numberify any prerelease numeric ids\n  if (!m[4])\n    this.prerelease = [];\n  else\n    this.prerelease = m[4].split('.').map(function(id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER)\n          return num\n      }\n      return id;\n    });\n\n  this.build = m[5] ? m[5].split('.') : [];\n  this.format();\n}\n\nSemVer.prototype.format = function() {\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\n  if (this.prerelease.length)\n    this.version += '-' + this.prerelease.join('.');\n  return this.version;\n};\n\nSemVer.prototype.inspect = function() {\n  return '<SemVer \"' + this + '\">';\n};\n\nSemVer.prototype.toString = function() {\n  return this.version;\n};\n\nSemVer.prototype.compare = function(other) {\n  debug('SemVer.compare', this.version, this.loose, other);\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return this.compareMain(other) || this.comparePre(other);\n};\n\nSemVer.prototype.compareMain = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch);\n};\n\nSemVer.prototype.comparePre = function(other) {\n  if (!(other instanceof SemVer))\n    other = new SemVer(other, this.loose);\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length)\n    return -1;\n  else if (!this.prerelease.length && other.prerelease.length)\n    return 1;\n  else if (!this.prerelease.length && !other.prerelease.length)\n    return 0;\n\n  var i = 0;\n  do {\n    var a = this.prerelease[i];\n    var b = other.prerelease[i];\n    debug('prerelease compare', i, a, b);\n    if (a === undefined && b === undefined)\n      return 0;\n    else if (b === undefined)\n      return 1;\n    else if (a === undefined)\n      return -1;\n    else if (a === b)\n      continue;\n    else\n      return compareIdentifiers(a, b);\n  } while (++i);\n};\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function(release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor = 0;\n      this.major++;\n      this.inc('pre', identifier);\n      break;\n    case 'preminor':\n      this.prerelease.length = 0;\n      this.patch = 0;\n      this.minor++;\n      this.inc('pre', identifier);\n      break;\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0;\n      this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0)\n        this.inc('patch', identifier);\n      this.inc('pre', identifier);\n      break;\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0)\n        this.major++;\n      this.minor = 0;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0)\n        this.minor++;\n      this.patch = 0;\n      this.prerelease = [];\n      break;\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0)\n        this.patch++;\n      this.prerelease = [];\n      break;\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0)\n        this.prerelease = [0];\n      else {\n        var i = this.prerelease.length;\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++;\n            i = -2;\n          }\n        }\n        if (i === -1) // didn't increment anything\n          this.prerelease.push(0);\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1]))\n            this.prerelease = [identifier, 0];\n        } else\n          this.prerelease = [identifier, 0];\n      }\n      break;\n\n    default:\n      throw new Error('invalid increment argument: ' + release);\n  }\n  this.format();\n  return this;\n};\n\nexports.inc = inc;\nfunction inc(version, release, loose, identifier) {\n  if (typeof(loose) === 'string') {\n    identifier = loose;\n    loose = undefined;\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version;\n  } catch (er) {\n    return null;\n  }\n}\n\nexports.diff = diff;\nfunction diff(version1, version2) {\n  if (eq(version1, version2)) {\n    return null;\n  } else {\n    var v1 = parse(version1);\n    var v2 = parse(version2);\n    if (v1.prerelease.length || v2.prerelease.length) {\n      for (var key in v1) {\n        if (key === 'major' || key === 'minor' || key === 'patch') {\n          if (v1[key] !== v2[key]) {\n            return 'pre'+key;\n          }\n        }\n      }\n      return 'prerelease';\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return key;\n        }\n      }\n    }\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers;\n\nvar numeric = /^[0-9]+$/;\nfunction compareIdentifiers(a, b) {\n  var anum = numeric.test(a);\n  var bnum = numeric.test(b);\n\n  if (anum && bnum) {\n    a = +a;\n    b = +b;\n  }\n\n  return (anum && !bnum) ? -1 :\n         (bnum && !anum) ? 1 :\n         a < b ? -1 :\n         a > b ? 1 :\n         0;\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers;\nfunction rcompareIdentifiers(a, b) {\n  return compareIdentifiers(b, a);\n}\n\nexports.major = major;\nfunction major(a, loose) {\n  return new SemVer(a, loose).major;\n}\n\nexports.minor = minor;\nfunction minor(a, loose) {\n  return new SemVer(a, loose).minor;\n}\n\nexports.patch = patch;\nfunction patch(a, loose) {\n  return new SemVer(a, loose).patch;\n}\n\nexports.compare = compare;\nfunction compare(a, b, loose) {\n  return new SemVer(a, loose).compare(b);\n}\n\nexports.compareLoose = compareLoose;\nfunction compareLoose(a, b) {\n  return compare(a, b, true);\n}\n\nexports.rcompare = rcompare;\nfunction rcompare(a, b, loose) {\n  return compare(b, a, loose);\n}\n\nexports.sort = sort;\nfunction sort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.compare(a, b, loose);\n  });\n}\n\nexports.rsort = rsort;\nfunction rsort(list, loose) {\n  return list.sort(function(a, b) {\n    return exports.rcompare(a, b, loose);\n  });\n}\n\nexports.gt = gt;\nfunction gt(a, b, loose) {\n  return compare(a, b, loose) > 0;\n}\n\nexports.lt = lt;\nfunction lt(a, b, loose) {\n  return compare(a, b, loose) < 0;\n}\n\nexports.eq = eq;\nfunction eq(a, b, loose) {\n  return compare(a, b, loose) === 0;\n}\n\nexports.neq = neq;\nfunction neq(a, b, loose) {\n  return compare(a, b, loose) !== 0;\n}\n\nexports.gte = gte;\nfunction gte(a, b, loose) {\n  return compare(a, b, loose) >= 0;\n}\n\nexports.lte = lte;\nfunction lte(a, b, loose) {\n  return compare(a, b, loose) <= 0;\n}\n\nexports.cmp = cmp;\nfunction cmp(a, op, b, loose) {\n  var ret;\n  switch (op) {\n    case '===':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a === b;\n      break;\n    case '!==':\n      if (typeof a === 'object') a = a.version;\n      if (typeof b === 'object') b = b.version;\n      ret = a !== b;\n      break;\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\n    case '!=': ret = neq(a, b, loose); break;\n    case '>': ret = gt(a, b, loose); break;\n    case '>=': ret = gte(a, b, loose); break;\n    case '<': ret = lt(a, b, loose); break;\n    case '<=': ret = lte(a, b, loose); break;\n    default: throw new TypeError('Invalid operator: ' + op);\n  }\n  return ret;\n}\n\nexports.Comparator = Comparator;\nfunction Comparator(comp, loose) {\n  if (comp instanceof Comparator) {\n    if (comp.loose === loose)\n      return comp;\n    else\n      comp = comp.value;\n  }\n\n  if (!(this instanceof Comparator))\n    return new Comparator(comp, loose);\n\n  debug('comparator', comp, loose);\n  this.loose = loose;\n  this.parse(comp);\n\n  if (this.semver === ANY)\n    this.value = '';\n  else\n    this.value = this.operator + this.semver.version;\n\n  debug('comp', this);\n}\n\nvar ANY = {};\nComparator.prototype.parse = function(comp) {\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var m = comp.match(r);\n\n  if (!m)\n    throw new TypeError('Invalid comparator: ' + comp);\n\n  this.operator = m[1];\n  if (this.operator === '=')\n    this.operator = '';\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2])\n    this.semver = ANY;\n  else\n    this.semver = new SemVer(m[2], this.loose);\n};\n\nComparator.prototype.inspect = function() {\n  return '<SemVer Comparator \"' + this + '\">';\n};\n\nComparator.prototype.toString = function() {\n  return this.value;\n};\n\nComparator.prototype.test = function(version) {\n  debug('Comparator.test', version, this.loose);\n\n  if (this.semver === ANY)\n    return true;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  return cmp(version, this.operator, this.semver, this.loose);\n};\n\n\nexports.Range = Range;\nfunction Range(range, loose) {\n  if ((range instanceof Range) && range.loose === loose)\n    return range;\n\n  if (!(this instanceof Range))\n    return new Range(range, loose);\n\n  this.loose = loose;\n\n  // First, split based on boolean or ||\n  this.raw = range;\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\n    return this.parseRange(range.trim());\n  }, this).filter(function(c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length;\n  });\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range);\n  }\n\n  this.format();\n}\n\nRange.prototype.inspect = function() {\n  return '<SemVer Range \"' + this.range + '\">';\n};\n\nRange.prototype.format = function() {\n  this.range = this.set.map(function(comps) {\n    return comps.join(' ').trim();\n  }).join('||').trim();\n  return this.range;\n};\n\nRange.prototype.toString = function() {\n  return this.range;\n};\n\nRange.prototype.parseRange = function(range) {\n  var loose = this.loose;\n  range = range.trim();\n  debug('range', range, loose);\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\n  range = range.replace(hr, hyphenReplace);\n  debug('hyphen replace', range);\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\n  debug('comparator trim', range, re[COMPARATORTRIM]);\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ');\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\n  var set = range.split(' ').map(function(comp) {\n    return parseComparator(comp, loose);\n  }).join(' ').split(/\\s+/);\n  if (this.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function(comp) {\n      return !!comp.match(compRe);\n    });\n  }\n  set = set.map(function(comp) {\n    return new Comparator(comp, loose);\n  });\n\n  return set;\n};\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators;\nfunction toComparators(range, loose) {\n  return new Range(range, loose).set.map(function(comp) {\n    return comp.map(function(c) {\n      return c.value;\n    }).join(' ').trim().split(' ');\n  });\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator(comp, loose) {\n  debug('comp', comp);\n  comp = replaceCarets(comp, loose);\n  debug('caret', comp);\n  comp = replaceTildes(comp, loose);\n  debug('tildes', comp);\n  comp = replaceXRanges(comp, loose);\n  debug('xrange', comp);\n  comp = replaceStars(comp, loose);\n  debug('stars', comp);\n  return comp;\n}\n\nfunction isX(id) {\n  return !id || id.toLowerCase() === 'x' || id === '*';\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceTilde(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceTilde(comp, loose) {\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p))\n      // ~1.2 == >=1.2.0- <1.3.0-\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    else if (pr) {\n      debug('replaceTilde pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      ret = '>=' + M + '.' + m + '.' + p + pr +\n            ' <' + M + '.' + (+m + 1) + '.0';\n    } else\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0';\n\n    debug('tilde return', ret);\n    return ret;\n  });\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets(comp, loose) {\n  return comp.trim().split(/\\s+/).map(function(comp) {\n    return replaceCaret(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceCaret(comp, loose) {\n  debug('caret', comp, loose);\n  var r = loose ? re[CARETLOOSE] : re[CARET];\n  return comp.replace(r, function(_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr);\n    var ret;\n\n    if (isX(M))\n      ret = '';\n    else if (isX(m))\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    else if (isX(p)) {\n      if (M === '0')\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n      else\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';\n    } else if (pr) {\n      debug('replaceCaret pr', pr);\n      if (pr.charAt(0) !== '-')\n        pr = '-' + pr;\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p + pr +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p + pr +\n              ' <' + (+M + 1) + '.0.0';\n    } else {\n      debug('no pr');\n      if (M === '0') {\n        if (m === '0')\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1);\n        else\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0';\n      } else\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0';\n    }\n\n    debug('caret return', ret);\n    return ret;\n  });\n}\n\nfunction replaceXRanges(comp, loose) {\n  debug('replaceXRanges', comp, loose);\n  return comp.split(/\\s+/).map(function(comp) {\n    return replaceXRange(comp, loose);\n  }).join(' ');\n}\n\nfunction replaceXRange(comp, loose) {\n  comp = comp.trim();\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr);\n    var xM = isX(M);\n    var xm = xM || isX(m);\n    var xp = xm || isX(p);\n    var anyX = xp;\n\n    if (gtlt === '=' && anyX)\n      gtlt = '';\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0';\n      } else {\n        // nothing is forbidden\n        ret = '*';\n      }\n    } else if (gtlt && anyX) {\n      // replace X with 0\n      if (xm)\n        m = 0;\n      if (xp)\n        p = 0;\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>=';\n        if (xm) {\n          M = +M + 1;\n          m = 0;\n          p = 0;\n        } else if (xp) {\n          m = +m + 1;\n          p = 0;\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm)\n          M = +M + 1\n        else\n          m = +m + 1\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p;\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';\n    }\n\n    debug('xRange return', ret);\n\n    return ret;\n  });\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars(comp, loose) {\n  debug('replaceStars', comp, loose);\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '');\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace($0,\n                       from, fM, fm, fp, fpr, fb,\n                       to, tM, tm, tp, tpr, tb) {\n\n  if (isX(fM))\n    from = '';\n  else if (isX(fm))\n    from = '>=' + fM + '.0.0';\n  else if (isX(fp))\n    from = '>=' + fM + '.' + fm + '.0';\n  else\n    from = '>=' + from;\n\n  if (isX(tM))\n    to = '';\n  else if (isX(tm))\n    to = '<' + (+tM + 1) + '.0.0';\n  else if (isX(tp))\n    to = '<' + tM + '.' + (+tm + 1) + '.0';\n  else if (tpr)\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\n  else\n    to = '<=' + to;\n\n  return (from + ' ' + to).trim();\n}\n\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function(version) {\n  if (!version)\n    return false;\n\n  if (typeof version === 'string')\n    version = new SemVer(version, this.loose);\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version))\n      return true;\n  }\n  return false;\n};\n\nfunction testSet(set, version) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version))\n      return false;\n  }\n\n  if (version.prerelease.length) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (var i = 0; i < set.length; i++) {\n      debug(set[i].semver);\n      if (set[i].semver === ANY)\n        continue;\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver;\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch)\n          return true;\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false;\n  }\n\n  return true;\n}\n\nexports.satisfies = satisfies;\nfunction satisfies(version, range, loose) {\n  try {\n    range = new Range(range, loose);\n  } catch (er) {\n    return false;\n  }\n  return range.test(version);\n}\n\nexports.maxSatisfying = maxSatisfying;\nfunction maxSatisfying(versions, range, loose) {\n  return versions.filter(function(version) {\n    return satisfies(version, range, loose);\n  }).sort(function(a, b) {\n    return rcompare(a, b, loose);\n  })[0] || null;\n}\n\nexports.validRange = validRange;\nfunction validRange(range, loose) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, loose).range || '*';\n  } catch (er) {\n    return null;\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr;\nfunction ltr(version, range, loose) {\n  return outside(version, range, '<', loose);\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr;\nfunction gtr(version, range, loose) {\n  return outside(version, range, '>', loose);\n}\n\nexports.outside = outside;\nfunction outside(version, range, hilo, loose) {\n  version = new SemVer(version, loose);\n  range = new Range(range, loose);\n\n  var gtfn, ltefn, ltfn, comp, ecomp;\n  switch (hilo) {\n    case '>':\n      gtfn = gt;\n      ltefn = lte;\n      ltfn = lt;\n      comp = '>';\n      ecomp = '>=';\n      break;\n    case '<':\n      gtfn = lt;\n      ltefn = gte;\n      ltfn = gt;\n      comp = '<';\n      ecomp = '<=';\n      break;\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"');\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, loose)) {\n    return false;\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i];\n\n    var high = null;\n    var low = null;\n\n    comparators.forEach(function(comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator;\n      low = low || comparator;\n      if (gtfn(comparator.semver, high.semver, loose)) {\n        high = comparator;\n      } else if (ltfn(comparator.semver, low.semver, loose)) {\n        low = comparator;\n      }\n    });\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false;\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false;\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Use the define() function if we're in AMD land\nif (typeof define === 'function' && define.amd)\n  define(exports);\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova/src/cli.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint node:true, bitwise:true, undef:true, trailing:true, quotmark:true,\n          indent:4, unused:vars, latedef:nofunc,\n          laxcomma:true\n*/\n\n\nvar path = require('path'),\n    help = require('./help'),\n    nopt,\n    _,\n    updateNotifier,\n    pkg = require('../package.json'),\n    telemetry = require('./telemetry'),\n    Q = require('q');\n\nvar cordova_lib = require('cordova-lib'),\n    CordovaError = cordova_lib.CordovaError,\n    cordova = cordova_lib.cordova,\n    events = cordova_lib.events,\n    logger = require('cordova-common').CordovaLogger.get();\n\nvar msg,\n    badPlatforms;\n\n\n/*\n * init\n *\n * initializes nopt and underscore\n * nopt and underscore are require()d in try-catch below to print a nice error\n * message if one of them is not installed.\n */\nfunction init() {\n    try {\n        nopt = require('nopt');\n        _ = require('underscore');\n        updateNotifier = require('update-notifier');\n    } catch (e) {\n        console.error(\n            'Please run npm install from this directory:\\n\\t' +\n            path.dirname(__dirname)\n        );\n        process.exit(2);\n    }\n}\n\nfunction checkForUpdates() {\n    try {\n        // Checks for available update and returns an instance\n        var notifier = updateNotifier({\n            pkg: pkg\n        });\n\n        // Notify using the built-in convenience method\n        notifier.notify();\n    } catch (e) {\n        // https://issues.apache.org/jira/browse/CB-10062\n        if (e && e.message && /EACCES/.test(e.message)) {\n            console.log('Update notifier was not able to access the config file.\\n' +\n                'You may grant permissions to the file: \\'sudo chmod 744 ~/.config/configstore/update-notifier-cordova.json\\'');\n        } else {\n            throw e;\n        }\n    }\n}\n\nvar shouldCollectTelemetry = false;\nmodule.exports = function (inputArgs, cb) {\n    \n    /**\n     * mainly used for testing.\n     */\n    cb = cb || function(){};\n    \n    init();\n    \n    // If no inputArgs given, use process.argv.\n    inputArgs = inputArgs || process.argv;\n    var cmd = inputArgs[2]; // e.g: inputArgs= 'node cordova run ios'\n    var subcommand = getSubCommand(inputArgs, cmd);\n    var isTelemetryCmd = (cmd === 'telemetry');\n\n    // ToDO: Move nopt-based parsing of args up here\n    if(cmd === '--version' || cmd === '-v') {\n        cmd = 'version';\n    } else if(!cmd || cmd === '--help' || cmd === 'h') {\n        cmd = 'help';\n    }\n            \n    Q().then(function() {\n        \n        /**\n         * Skip telemetry prompt if:\n         * - CI environment variable is present\n         * - Command is run with `--no-telemetry` flag\n         * - Command ran is: `cordova telemetry on | off | ...`\n         */\n        \n        if(telemetry.isCI(process.env) || telemetry.isNoTelemetryFlag(inputArgs)) {\n            return Q(false);\n        }\n        \n        /**\n         * We shouldn't prompt for telemetry if user issues a command of the form: `cordova telemetry on | off | ...x`\n         * Also, if the user has already been prompted and made a decision, use his saved answer\n         */\n        if(isTelemetryCmd) {\n            var isOptedIn = telemetry.isOptedIn();\n            return handleTelemetryCmd(subcommand, isOptedIn);\n        }\n        \n        if(telemetry.hasUserOptedInOrOut()) {\n            return Q(telemetry.isOptedIn());\n        }\n        \n        /**\n         * Otherwise, prompt user to opt-in or out\n         * Note: the prompt is shown for 30 seconds. If no choice is made by that time, User is considered to have opted out.\n         */\n        return telemetry.showPrompt();\n    }).then(function (collectTelemetry) {\n        shouldCollectTelemetry = collectTelemetry;\n        if(isTelemetryCmd) {\n            return Q();\n        }\n        return cli(inputArgs);\n    }).then(function () {\n        if (shouldCollectTelemetry && !isTelemetryCmd) {\n            telemetry.track(cmd, subcommand, 'successful');\n        }\n        // call cb with error as arg if something failed\n        cb(null);\n    }).fail(function (err) {\n        if (shouldCollectTelemetry && !isTelemetryCmd) {\n            telemetry.track(cmd, subcommand, 'unsuccessful');\n        }\n        // call cb with error as arg if something failed\n        cb(err);\n        throw err;\n    }).done();\n};\n\nfunction getSubCommand(args, cmd) {\n    if(cmd === 'platform' || cmd === 'platforms' || cmd === 'plugin' || cmd === 'plugins' || cmd === 'telemetry') {\n        return args[3]; // e.g: args='node cordova platform rm ios', 'node cordova telemetry on'\n    }\n    return null;\n}\n\nfunction handleTelemetryCmd(subcommand, isOptedIn) {\n    \n    if (subcommand !== 'on' && subcommand !== 'off') {\n        logger.subscribe(events);\n        return help(['telemetry']);\n    }\n    \n    var turnOn = subcommand === 'on' ? true : false;\n    var cmdSuccess = true;\n\n    // turn telemetry on or off\n    try {\n        if (turnOn) {\n            telemetry.turnOn();\n            console.log('Thanks for opting into telemetry to help us improve cordova.');\n        } else {\n            telemetry.turnOff();\n            console.log('You have been opted out of telemetry. To change this, run: cordova telemetry on.');\n        }\n    } catch (ex) {\n        cmdSuccess = false;\n    }\n\n    // track or not track ?, that is the question\n\n    if (!turnOn) {\n        // Always track telemetry opt-outs (whether user opted out or not!)\n        telemetry.track('telemetry', 'off', 'via-cordova-telemetry-cmd', cmdSuccess ? 'successful': 'unsuccessful');\n        return Q();\n    }\n    \n    if(isOptedIn) {\n        telemetry.track('telemetry', 'on', 'via-cordova-telemetry-cmd', cmdSuccess ? 'successful' : 'unsuccessful');\n    }\n    \n    return Q();\n}\n\nfunction cli(inputArgs) {\n    // When changing command line arguments, update doc/help.txt accordingly.\n    var knownOpts =\n        { 'verbose' : Boolean\n        , 'version' : Boolean\n        , 'help' : Boolean\n        , 'silent' : Boolean\n        , 'experimental' : Boolean\n        , 'noregistry' : Boolean\n        , 'nohooks': Array\n        , 'shrinkwrap' : Boolean\n        , 'copy-from' : String\n        , 'link-to' : path\n        , 'searchpath' : String\n        , 'variable' : Array\n        , 'link': Boolean\n        , 'force': Boolean\n        // Flags to be passed to `cordova build/run/emulate`\n        , 'debug' : Boolean\n        , 'release' : Boolean\n        , 'archs' : String\n        , 'device' : Boolean\n        , 'emulator': Boolean\n        , 'target' : String\n        , 'browserify': Boolean\n        , 'noprepare': Boolean\n        , 'fetch': Boolean\n        , 'nobuild': Boolean\n        , 'list': Boolean\n        , 'buildConfig' : String\n        , 'template' : String\n        };\n\n    var shortHands =\n        { 'd' : '--verbose'\n        , 'v' : '--version'\n        , 'h' : '--help'\n        , 'src' : '--copy-from'\n        , 't' : '--template'\n        };\n\n    checkForUpdates();\n\n    var args = nopt(knownOpts, shortHands, inputArgs);\n\n    // For CordovaError print only the message without stack trace unless we\n    // are in a verbose mode.\n    process.on('uncaughtException', function(err) {\n        logger.error(err);\n        // Don't send exception details, just send that it happened\n        if(shouldCollectTelemetry) {\n            telemetry.track('uncaughtException');\n        }\n        process.exit(1);\n    });\n\n    logger.subscribe(events);\n\n    if (args.silent) {\n        logger.setLevel('error');\n    }\n\n    if (args.verbose) {\n        logger.setLevel('verbose');\n    }\n\n    var cliVersion = require('../package').version;\n    // TODO: Use semver.prerelease when it gets released\n    var usingPrerelease = /-nightly|-dev$/.exec(cliVersion);\n    if (args.version || usingPrerelease) {\n        var libVersion = require('cordova-lib/package').version;\n        var toPrint = cliVersion;\n        if (cliVersion != libVersion || usingPrerelease) {\n            toPrint += ' (cordova-lib@' + libVersion + ')';\n        }\n\n        if (args.version) {\n            logger.results(toPrint);\n            return Q();\n        } else {\n            // Show a warning and continue\n            logger.warn('Warning: using prerelease version ' + toPrint);\n        }\n    }\n\n    if (/^v0.\\d+[.\\d+]*/.exec(process.version)) { // matches v0.* \n        msg = 'Warning: using node version ' + process.version +\n                ' which has been deprecated. Please upgrade to the latest node version available (v6.x is recommended).';\n        logger.warn(msg);\n    }\n\n    // If there were arguments protected from nopt with a double dash, keep\n    // them in unparsedArgs. For example:\n    // cordova build ios -- --verbose --whatever\n    // In this case \"--verbose\" is not parsed by nopt and args.vergbose will be\n    // false, the unparsed args after -- are kept in unparsedArgs and can be\n    // passed downstream to some scripts invoked by Cordova.\n    var unparsedArgs = [];\n    var parseStopperIdx =  args.argv.original.indexOf('--');\n    if (parseStopperIdx != -1) {\n        unparsedArgs = args.argv.original.slice(parseStopperIdx + 1);\n    }\n\n    // args.argv.remain contains both the undashed args (like platform names)\n    // and whatever unparsed args that were protected by \" -- \".\n    // \"undashed\" stores only the undashed args without those after \" -- \" .\n    var remain = args.argv.remain;\n    var undashed = remain.slice(0, remain.length - unparsedArgs.length);\n    var cmd = undashed[0];\n    var subcommand;\n    var known_platforms = Object.keys(cordova_lib.cordova_platforms);\n    msg = '';\n\n    if ( !cmd || cmd == 'help' || args.help ) {\n        if (!args.help && remain[0] == 'help') {\n            remain.shift();\n        }\n        return help(remain);\n    }\n\n    if ( !cordova.hasOwnProperty(cmd) ) {\n        msg =\n            'Cordova does not know ' + cmd + '; try `' + cordova_lib.binname +\n            ' help` for a list of all the available commands.';\n        throw new CordovaError(msg);\n    }\n\n    var opts = {\n        platforms: [],\n        options: [],\n        verbose: args.verbose || false,\n        silent: args.silent || false,\n        browserify: args.browserify || false,\n        fetch: args.fetch || false,\n        nohooks: args.nohooks || [],\n        searchpath : args.searchpath\n    };\n\n\n    if (cmd == 'emulate' || cmd == 'build' || cmd == 'prepare' || cmd == 'compile' || cmd == 'run' || cmd === 'clean') {\n        // All options without dashes are assumed to be platform names\n        opts.platforms = undashed.slice(1);\n        badPlatforms = _.difference(opts.platforms, known_platforms);\n        if( !_.isEmpty(badPlatforms) ) {\n            msg = 'Unknown platforms: ' + badPlatforms.join(', ');\n            throw new CordovaError(msg);\n        }\n\n        // Pass nopt-parsed args to PlatformApi through opts.options\n        opts.options = args;\n        opts.options.argv = unparsedArgs;\n\n        if (cmd === 'run' && args.list && cordova.raw.targets) {\n            return cordova.raw.targets.call(null, opts);\n        }\n\n        return cordova.raw[cmd].call(null, opts);\n    } else if (cmd === 'requirements') {\n        // All options without dashes are assumed to be platform names\n        opts.platforms = undashed.slice(1);\n        badPlatforms = _.difference(opts.platforms, known_platforms);\n        if( !_.isEmpty(badPlatforms) ) {\n            msg = 'Unknown platforms: ' + badPlatforms.join(', ');\n            throw new CordovaError(msg);\n        }\n\n        return cordova.raw[cmd].call(null, opts.platforms)\n            .then(function(platformChecks) {\n\n                var someChecksFailed = Object.keys(platformChecks).map(function(platformName) {\n                    events.emit('log', '\\nRequirements check results for ' + platformName + ':');\n                    var platformCheck = platformChecks[platformName];\n                    if (platformCheck instanceof CordovaError) {\n                        events.emit('warn', 'Check failed for ' + platformName + ' due to ' + platformCheck);\n                        return true;\n                    }\n\n                    var someChecksFailed = false;\n                    platformCheck.forEach(function(checkItem) {\n                        var checkSummary = checkItem.name + ': ' +\n                            (checkItem.installed ? 'installed ' : 'not installed ') +\n                            (checkItem.metadata.version || '');\n                        events.emit('log', checkSummary);\n                        if (!checkItem.installed) {\n                            someChecksFailed = true;\n                            events.emit('warn', checkItem.metadata.reason);\n                        }\n                    });\n\n                    return someChecksFailed;\n                }).some(function(isCheckFailedForPlatform) {\n                    return isCheckFailedForPlatform;\n                });\n\n                if (someChecksFailed) throw new CordovaError('Some of requirements check failed');\n            });\n    } else if (cmd == 'serve') {\n        var port = undashed[1];\n        return cordova.raw.serve(port);\n    } else if (cmd == 'create') {\n        return create();\n    } else {\n        // platform/plugins add/rm [target(s)]\n        subcommand = undashed[1]; // sub-command like \"add\", \"ls\", \"rm\" etc.\n        var targets = undashed.slice(2); // array of targets, either platforms or plugins\n        var cli_vars = {};\n        if (args.variable) {\n            args.variable.forEach(function (s) {\n                // CB-9171\n                var eq = s.indexOf('=');\n                if (eq == -1)\n                    throw new CordovaError('invalid variable format: ' + s);\n                var key = s.substr(0, eq).toUpperCase();\n                var val = s.substr(eq + 1, s.length);\n                cli_vars[key] = val;\n            });\n        }\n        var download_opts = { searchpath : args.searchpath\n                            , noregistry : args.noregistry\n                            , nohooks : args.nohooks\n                            , cli_variables : cli_vars\n                            , browserify: args.browserify || false\n                            , fetch: args.fetch || false\n                            , link: args.link || false\n                            , save: args.save || false\n                            , shrinkwrap: args.shrinkwrap || false\n                            , force: args.force || false\n                            };\n        return cordova.raw[cmd](subcommand, targets, download_opts);\n    }\n\n    function create() {\n        var cfg;            // Create config\n        var customWww;      // Template path\n        var wwwCfg;         // Template config\n\n        // If we got a fourth parameter, consider it to be JSON to init the config.\n        if (undashed[4])\n            cfg = JSON.parse(undashed[4]);\n        else\n            cfg = {};\n\n        customWww = args['copy-from'] || args['link-to'] || args.template;\n\n        if (customWww) {\n            if (!args.template && !args['copy-from'] && customWww.indexOf('http') === 0) {\n                throw new CordovaError(\n                    'Only local paths for custom www assets are supported for linking' + customWww\n                );\n            }\n\n            // Resolve tilda\n            if (customWww.substr(0,1) === '~')\n                customWww = path.join(process.env.HOME,  customWww.substr(1));\n\n            wwwCfg = {\n                url: customWww,\n                template: false,\n                link: false\n            };\n\n            if (args['link-to']) {\n                wwwCfg.link = true;\n            }\n            if (args.template) {\n                wwwCfg.template = true;\n            } else if (args['copy-from']) {\n                logger.warn('Warning: --copy-from option is being deprecated. Consider using --template instead.');\n                wwwCfg.template = true;\n            }\n\n            cfg.lib = cfg.lib || {};\n            cfg.lib.www = wwwCfg;\n        }\n        return cordova.raw.create( undashed[1]  // dir to create the project in\n            , undashed[2]  // App id\n            , undashed[3]  // App name\n            , cfg\n            , events || undefined\n        );\n    }\n}\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova/src/help.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\nvar fs = require('fs'),\n    cordova_lib = require('cordova-lib'),\n    cordova = cordova_lib.cordova,\n    Q = require('q'),\n    path = require('path');\n\nmodule.exports = function help (args) {\n    var command,\n        file,\n        raw,\n        docdir;\n    args = args || [];\n    command = ((args)[0] || 'cordova');\n    docdir = path.join(__dirname, '..', 'doc');\n    file = [\n      command + '.md',\n      command + '.txt',\n      'cordova.md',\n      'cordova.txt',\n    ].map(function (file) {\n        var f = path.join(docdir, file);\n        if (fs.existsSync(f)) {\n           return f;\n        }\n        return null;\n    }).filter(function (f) {\n        return f !== null;\n    });\n    raw = fs.readFileSync(file[0]).toString('utf8').replace(/cordova-cli/g, cordova_lib.binname);\n    cordova.emit('results', raw);\n    return Q();\n};\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova/src/telemetry.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint node:true, bitwise:true, undef:true, trailing:true, quotmark:true,\n          indent:4, unused:vars, latedef:nofunc,\n          laxcomma:true\n*/\n\n\n\n// For further details on telemetry, see:\n// https://github.com/cordova/cordova-discuss/pull/43\n\nvar Q = require('q');\n\n// Google Analytics tracking code\nvar GA_TRACKING_CODE = 'UA-64283057-7';\n\nvar pkg = require('../package.json');\nvar Insight = require('insight');\nvar insight = new Insight({\n    trackingCode: GA_TRACKING_CODE,\n    pkg: pkg\n});\n\n/**\n * Returns true if the user opted in, and false otherwise\n */\nfunction showPrompt() {\n\n    var deferred = Q.defer();\n    \n    var msg = 'May Cordova anonymously report usage statistics to improve the tool over time?';\n    insight.askPermission(msg, function (unused, optIn) {\n        var EOL = require('os').EOL;\n        if (optIn) {\n            console.log(EOL + 'Thanks for opting into telemetry to help us improve cordova.');\n            track('telemetry', 'on', 'via-cli-prompt-choice', 'successful');\n        } else {\n            console.log(EOL + 'You have been opted out of telemetry. To change this, run: cordova telemetry on.');\n            // Always track telemetry opt-outs! (whether opted-in or opted-out)\n            track('telemetry', 'off', 'via-cli-prompt-choice', 'successful');\n        }\n        \n        deferred.resolve(optIn); \n    });\n    \n    return deferred.promise;\n}\n\nfunction track() {\n    // Remove empty, null or undefined strings from arguments\n    for (var property in arguments) {\n        var val = arguments[property]; \n        if (!val || val.length === 0) {\n            delete arguments.property;\n        }\n    }\n    insight.track.apply(insight, arguments);\n}\n\nfunction turnOn() {\n    insight.optOut = false;\n}\n\nfunction turnOff() {\n    insight.optOut = true;\n}\n\n/**\n * Clears telemetry setting\n * Has the same effect as if user never answered the telemetry prompt\n * Useful for testing purposes\n */\nfunction clear() {\n    insight.optOut = undefined;\n}\n\nfunction isOptedIn() {\n    return !insight.optOut;\n}\n\n/**\n * Has the user already answered the telemetry prompt? (thereby opting in or out?)\n */\nfunction hasUserOptedInOrOut() {\n    var insightOptOut = insight.optOut === undefined;\n    return !(insightOptOut);\n}\n\n/**\n * Is the environment variable 'CI' specified ?\n */\nfunction isCI(env) {\n    return !!env.CI;\n}\n\n/**\n * Has the user ran a command of the form: `cordova run --no-telemetry` ?\n */\nfunction isNoTelemetryFlag(args) {\n    return args.indexOf('--no-telemetry') > -1;\n}\n\nmodule.exports = {\n    track: track,\n    turnOn: turnOn,\n    turnOff: turnOff,\n    clear: clear,\n    isOptedIn: isOptedIn,\n    hasUserOptedInOrOut: hasUserOptedInOrOut,\n    isCI: isCI,\n    showPrompt: showPrompt,\n    isNoTelemetryFlag: isNoTelemetryFlag\n};","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/CordovaLogger.js":"/*\r\n Licensed to the Apache Software Foundation (ASF) under one\r\n or more contributor license agreements.  See the NOTICE file\r\n distributed with this work for additional information\r\n regarding copyright ownership.  The ASF licenses this file\r\n to you under the Apache License, Version 2.0 (the\r\n \"License\"); you may not use this file except in compliance\r\n with the License.  You may obtain a copy of the License at\r\n\r\n http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n Unless required by applicable law or agreed to in writing,\r\n software distributed under the License is distributed on an\r\n \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n KIND, either express or implied.  See the License for the\r\n specific language governing permissions and limitations\r\n under the License.\r\n */\r\n\r\nvar ansi = require('ansi');\r\nvar EventEmitter = require('events').EventEmitter;\r\nvar CordovaError = require('./CordovaError/CordovaError');\r\nvar EOL = require('os').EOL;\r\n\r\nvar INSTANCE;\r\n\r\n/**\r\n * @class CordovaLogger\r\n *\r\n * Implements logging facility that anybody could use. Should not be\r\n *   instantiated directly, `CordovaLogger.get()` method should be used instead\r\n *   to acquire logger instance\r\n */\r\nfunction CordovaLogger () {\r\n    this.levels = {};\r\n    this.colors = {};\r\n    this.stdout = process.stdout;\r\n    this.stderr = process.stderr;\r\n\r\n    this.stdoutCursor = ansi(this.stdout);\r\n    this.stderrCursor = ansi(this.stderr);\r\n\r\n    this.addLevel('verbose', 1000, 'grey');\r\n    this.addLevel('normal' , 2000);\r\n    this.addLevel('warn'   , 2000, 'yellow');\r\n    this.addLevel('info'   , 3000, 'blue');\r\n    this.addLevel('error'  , 5000, 'red');\r\n    this.addLevel('results' , 10000);\r\n\r\n    this.setLevel('normal');\r\n}\r\n\r\n/**\r\n * Static method to create new or acquire existing instance.\r\n *\r\n * @return  {CordovaLogger}  Logger instance\r\n */\r\nCordovaLogger.get = function () {\r\n    return INSTANCE || (INSTANCE = new CordovaLogger());\r\n};\r\n\r\nCordovaLogger.VERBOSE = 'verbose';\r\nCordovaLogger.NORMAL = 'normal';\r\nCordovaLogger.WARN = 'warn';\r\nCordovaLogger.INFO = 'info';\r\nCordovaLogger.ERROR = 'error';\r\nCordovaLogger.RESULTS = 'results';\r\n\r\n/**\r\n * Emits log message to process' stdout/stderr depending on message's severity\r\n *   and current log level. If severity is less than current logger's level,\r\n *   then the message is ignored.\r\n *\r\n * @param   {String}  logLevel  The message's log level. The logger should have\r\n *   corresponding level added (via logger.addLevel), otherwise\r\n *   `CordovaLogger.NORMAL` level will be used.\r\n * @param   {String}  message   The message, that should be logged to process'\r\n *   stdio\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.log = function (logLevel, message) {\r\n    // if there is no such logLevel defined, or provided level has\r\n    // less severity than active level, then just ignore this call and return\r\n    if (!this.levels[logLevel] || this.levels[logLevel] < this.levels[this.logLevel])\r\n        // return instance to allow to chain calls\r\n        return this;\r\n\r\n    var isVerbose = this.logLevel === 'verbose';\r\n    var cursor = this.stdoutCursor;\r\n\r\n    if (message instanceof Error || logLevel === CordovaLogger.ERROR) {\r\n        message = formatError(message, isVerbose);\r\n        cursor = this.stderrCursor;\r\n    }\r\n\r\n    var color = this.colors[logLevel];\r\n    if (color) {\r\n        cursor.bold().fg[color]();\r\n    }\r\n\r\n    cursor.write(message).reset().write(EOL);\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Adds a new level to logger instance. This method also creates a shortcut\r\n *   method to log events with the level provided (i.e. after adding new level\r\n *   'debug', the method `debug(message)`, equal to logger.log('debug', message),\r\n *   will be added to logger instance)\r\n *\r\n * @param  {String}  level     A log level name. The levels with the following\r\n *   names added by default to every instance: 'verbose', 'normal', 'warn',\r\n *   'info', 'error', 'results'\r\n * @param  {Number}  severity  A number that represents level's severity.\r\n * @param  {String}  color     A valid color name, that will be used to log\r\n *   messages with this level. Any CSS color code or RGB value is allowed\r\n *   (according to ansi documentation:\r\n *   https://github.com/TooTallNate/ansi.js#features)\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.addLevel = function (level, severity, color) {\r\n\r\n    this.levels[level] = severity;\r\n\r\n    if (color) {\r\n        this.colors[level] = color;\r\n    }\r\n\r\n    // Define own method with corresponding name\r\n    if (!this[level]) {\r\n        this[level] = this.log.bind(this, level);\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the current logger level to provided value. If logger doesn't have level\r\n *   with this name, `CordovaLogger.NORMAL` will be used.\r\n *\r\n * @param  {String}  logLevel  Level name. The level with this name should be\r\n *   added to logger before.\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.setLevel = function (logLevel) {\r\n    this.logLevel = this.levels[logLevel] ? logLevel : CordovaLogger.NORMAL;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Adjusts the current logger level according to the passed options.\r\n *\r\n * @param   {Object|Array}  opts  An object or args array with options\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.adjustLevel = function (opts) {\r\n    if (opts.verbose || (Array.isArray(opts) && opts.indexOf('--verbose') !== -1)) {\r\n        this.setLevel('verbose');\r\n    } else if (opts.silent || (Array.isArray(opts) && opts.indexOf('--silent') !== -1)) {\r\n        this.setLevel('error');\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Attaches logger to EventEmitter instance provided.\r\n *\r\n * @param   {EventEmitter}  eventEmitter  An EventEmitter instance to attach\r\n *   logger to.\r\n *\r\n * @return  {CordovaLogger}     Current instance, to allow calls chaining.\r\n */\r\nCordovaLogger.prototype.subscribe = function (eventEmitter) {\r\n\r\n    if (!(eventEmitter instanceof EventEmitter))\r\n        throw new Error('Subscribe method only accepts an EventEmitter instance as argument');\r\n\r\n    eventEmitter.on('verbose', this.verbose)\r\n        .on('log', this.normal)\r\n        .on('info', this.info)\r\n        .on('warn', this.warn)\r\n        .on('warning', this.warn)\r\n        // Set up event handlers for logging and results emitted as events.\r\n        .on('results', this.results);\r\n\r\n    return this;\r\n};\r\n\r\nfunction formatError(error, isVerbose) {\r\n    var message = '';\r\n\r\n    if (error instanceof CordovaError) {\r\n        message = error.toString(isVerbose);\r\n    } else if (error instanceof Error) {\r\n        if (isVerbose) {\r\n            message = error.stack;\r\n        } else {\r\n            message = error.message;\r\n        }\r\n    } else {\r\n        // Plain text error message\r\n        message = error;\r\n    }\r\n\r\n    if (typeof message === 'string' && message.toUpperCase().indexOf('ERROR:') !== 0) {\r\n        // Needed for backward compatibility with external tools\r\n        message = 'Error: ' + message;\r\n    }\r\n\r\n    return message;\r\n}\r\n\r\nmodule.exports = CordovaLogger;\r\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/ConfigParser/ConfigParser.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true */\n\nvar et = require('elementtree'),\n    xml= require('../util/xml-helpers'),\n    CordovaError = require('../CordovaError/CordovaError'),\n    fs = require('fs'),\n    events = require('../events');\n\n\n/** Wraps a config.xml file */\nfunction ConfigParser(path) {\n    this.path = path;\n    try {\n        this.doc = xml.parseElementtreeSync(path);\n        this.cdvNamespacePrefix = getCordovaNamespacePrefix(this.doc);\n        et.register_namespace(this.cdvNamespacePrefix, 'http://cordova.apache.org/ns/1.0');\n    } catch (e) {\n        console.error('Parsing '+path+' failed');\n        throw e;\n    }\n    var r = this.doc.getroot();\n    if (r.tag !== 'widget') {\n        throw new CordovaError(path + ' has incorrect root node name (expected \"widget\", was \"' + r.tag + '\")');\n    }\n}\n\nfunction getNodeTextSafe(el) {\n    return el && el.text && el.text.trim();\n}\n\nfunction findOrCreate(doc, name) {\n    var ret = doc.find(name);\n    if (!ret) {\n        ret = new et.Element(name);\n        doc.getroot().append(ret);\n    }\n    return ret;\n}\n\nfunction getCordovaNamespacePrefix(doc){\n    var rootAtribs = Object.getOwnPropertyNames(doc.getroot().attrib);\n    var prefix = 'cdv';\n    for (var j = 0; j < rootAtribs.length; j++ ) {\n        if(rootAtribs[j].indexOf('xmlns:') === 0 &&\n            doc.getroot().attrib[rootAtribs[j]] === 'http://cordova.apache.org/ns/1.0'){\n            var strings = rootAtribs[j].split(':');\n            prefix = strings[1];\n            break;\n        }\n    }\n    return prefix;\n}\n\n/**\n * Finds the value of an element's attribute\n * @param  {String} attributeName Name of the attribute to search for\n * @param  {Array}  elems         An array of ElementTree nodes\n * @return {String}\n */\nfunction findElementAttributeValue(attributeName, elems) {\n\n    elems = Array.isArray(elems) ? elems : [ elems ];\n\n    var value = elems.filter(function (elem) {\n        return elem.attrib.name.toLowerCase() === attributeName.toLowerCase();\n    }).map(function (filteredElems) {\n        return filteredElems.attrib.value;\n    }).pop();\n\n    return value ? value : '';\n}\n\nConfigParser.prototype = {\n    getAttribute: function(attr) {\n        return this.doc.getroot().attrib[attr];\n    },\n\n    packageName: function(id) {\n        return this.getAttribute('id');\n    },\n    setPackageName: function(id) {\n        this.doc.getroot().attrib['id'] = id;\n    },\n    android_packageName: function() {\n        return this.getAttribute('android-packageName');\n    },\n    android_activityName: function() {\n        return this.getAttribute('android-activityName');\n    },\n    ios_CFBundleIdentifier: function() {\n        return this.getAttribute('ios-CFBundleIdentifier');\n    },\n    name: function() {\n        return getNodeTextSafe(this.doc.find('name'));\n    },\n    setName: function(name) {\n        var el = findOrCreate(this.doc, 'name');\n        el.text = name;\n    },\n    description: function() {\n        return getNodeTextSafe(this.doc.find('description'));\n    },\n    setDescription: function(text) {\n        var el = findOrCreate(this.doc, 'description');\n        el.text = text;\n    },\n    version: function() {\n        return this.getAttribute('version');\n    },\n    windows_packageVersion: function() {\n        return this.getAttribute('windows-packageVersion');\n    },\n    android_versionCode: function() {\n        return this.getAttribute('android-versionCode');\n    },\n    ios_CFBundleVersion: function() {\n        return this.getAttribute('ios-CFBundleVersion');\n    },\n    setVersion: function(value) {\n        this.doc.getroot().attrib['version'] = value;\n    },\n    author: function() {\n        return getNodeTextSafe(this.doc.find('author'));\n    },\n    getGlobalPreference: function (name) {\n        return findElementAttributeValue(name, this.doc.findall('preference'));\n    },\n    setGlobalPreference: function (name, value) {\n        var pref = this.doc.find('preference[@name=\"' + name + '\"]');\n        if (!pref) {\n            pref = new et.Element('preference');\n            pref.attrib.name = name;\n            this.doc.getroot().append(pref);\n        }\n        pref.attrib.value = value;\n    },\n    getPlatformPreference: function (name, platform) {\n        return findElementAttributeValue(name, this.doc.findall('platform[@name=\\'' + platform + '\\']/preference'));\n    },\n    getPreference: function(name, platform) {\n\n        var platformPreference = '';\n\n        if (platform) {\n            platformPreference = this.getPlatformPreference(name, platform);\n        }\n\n        return platformPreference ? platformPreference : this.getGlobalPreference(name);\n\n    },\n    /**\n     * Returns all resources for the platform specified.\n     * @param  {String} platform     The platform.\n     * @param {string}  resourceName Type of static resources to return.\n     *                               \"icon\" and \"splash\" currently supported.\n     * @return {Array}               Resources for the platform specified.\n     */\n    getStaticResources: function(platform, resourceName) {\n        var ret = [],\n            staticResources = [];\n        if (platform) { // platform specific icons\n            this.doc.findall('platform[@name=\\'' + platform + '\\']/' + resourceName).forEach(function(elt){\n                elt.platform = platform; // mark as platform specific resource\n                staticResources.push(elt);\n            });\n        }\n        // root level resources\n        staticResources = staticResources.concat(this.doc.findall(resourceName));\n        // parse resource elements\n        var that = this;\n        staticResources.forEach(function (elt) {\n            var res = {};\n            res.src = elt.attrib.src;\n            res.target = elt.attrib.target || undefined;\n            res.density = elt.attrib['density'] || elt.attrib[that.cdvNamespacePrefix+':density'] || elt.attrib['gap:density'];\n            res.platform = elt.platform || null; // null means icon represents default icon (shared between platforms)\n            res.width = +elt.attrib.width || undefined;\n            res.height = +elt.attrib.height || undefined;\n\n            // default icon\n            if (!res.width && !res.height && !res.density) {\n                ret.defaultResource = res;\n            }\n            ret.push(res);\n        });\n\n        /**\n         * Returns resource with specified width and/or height.\n         * @param  {number} width Width of resource.\n         * @param  {number} height Height of resource.\n         * @return {Resource} Resource object or null if not found.\n         */\n        ret.getBySize = function(width, height) {\n            return ret.filter(function(res) {\n                if (!res.width && !res.height) {\n                    return false;\n                }\n                return ((!res.width || (width == res.width)) &&\n                    (!res.height || (height == res.height)));\n            })[0] || null;\n        };\n\n        /**\n         * Returns resource with specified density.\n         * @param  {string} density Density of resource.\n         * @return {Resource}       Resource object or null if not found.\n         */\n        ret.getByDensity = function(density) {\n            return ret.filter(function(res) {\n                return res.density == density;\n            })[0] || null;\n        };\n\n        /** Returns default icons */\n        ret.getDefault = function() {\n            return ret.defaultResource;\n        };\n\n        return ret;\n    },\n\n    /**\n     * Returns all icons for specific platform.\n     * @param  {string} platform Platform name\n     * @return {Resource[]}      Array of icon objects.\n     */\n    getIcons: function(platform) {\n        return this.getStaticResources(platform, 'icon');\n    },\n\n    /**\n     * Returns all splash images for specific platform.\n     * @param  {string} platform Platform name\n     * @return {Resource[]}      Array of Splash objects.\n     */\n    getSplashScreens: function(platform) {\n        return this.getStaticResources(platform, 'splash');\n    },\n\n    /**\n     * Returns all resource-files for a specific platform.\n     * @param  {string} platform Platform name\n     * @return {Resource[]}      Array of resource file objects.\n     */\n    getFileResources: function(platform) {\n        var fileResources = [];\n\n        if (platform) { // platform specific resources\n            fileResources = this.doc.findall('platform[@name=\\'' + platform + '\\']/resource-file').map(function(tag) {\n                return {\n                    platform: platform,\n                    src: tag.attrib.src,\n                    target: tag.attrib.target,\n                    versions: tag.attrib.versions,\n                    deviceTarget: tag.attrib['device-target'],\n                    arch: tag.attrib.arch\n                };\n            });\n        }\n\n        return fileResources;\n    },\n\n    /**\n     * Returns all hook scripts for the hook type specified.\n     * @param  {String} hook     The hook type.\n     * @param {Array}  platforms Platforms to look for scripts into (root scripts will be included as well).\n     * @return {Array}               Script elements.\n     */\n    getHookScripts: function(hook, platforms) {\n        var self = this;\n        var scriptElements = self.doc.findall('./hook');\n\n        if(platforms) {\n            platforms.forEach(function (platform) {\n                scriptElements = scriptElements.concat(self.doc.findall('./platform[@name=\"' + platform + '\"]/hook'));\n            });\n        }\n\n        function filterScriptByHookType(el) {\n            return el.attrib.src && el.attrib.type && el.attrib.type.toLowerCase() === hook;\n        }\n\n        return scriptElements.filter(filterScriptByHookType);\n    },\n   /**\n    * Returns a list of plugin (IDs).\n    *\n    * This function also returns any plugin's that\n    * were defined using the legacy <feature> tags.\n    * @return {string[]} Array of plugin IDs\n    */\n    getPluginIdList: function () {\n        var plugins = this.doc.findall('plugin');\n        var result = plugins.map(function(plugin){\n            return plugin.attrib.name;\n        });\n        var features = this.doc.findall('feature');\n        features.forEach(function(element ){\n            var idTag = element.find('./param[@name=\"id\"]');\n            if(idTag){\n                result.push(idTag.attrib.value);\n            }\n        });\n        return result;\n    },\n    getPlugins: function () {\n        return this.getPluginIdList().map(function (pluginId) {\n            return this.getPlugin(pluginId);\n        }, this);\n    },\n    /**\n     * Adds a plugin element. Does not check for duplicates.\n     * @name addPlugin\n     * @function\n     * @param {object} attributes name and spec are supported\n     * @param {Array|object} variables name, value or arbitary object\n     */\n    addPlugin: function (attributes, variables) {\n        if (!attributes && !attributes.name) return;\n        var el = new et.Element('plugin');\n        el.attrib.name = attributes.name;\n        if (attributes.spec) {\n            el.attrib.spec = attributes.spec;\n        }\n\n        // support arbitrary object as variables source\n        if (variables && typeof variables === 'object' && !Array.isArray(variables)) {\n            variables = Object.keys(variables)\n            .map(function (variableName) {\n                return {name: variableName, value: variables[variableName]};\n            });\n        }\n\n        if (variables) {\n            variables.forEach(function (variable) {\n                el.append(new et.Element('variable', { name: variable.name, value: variable.value }));\n            });\n        }\n        this.doc.getroot().append(el);\n    },\n    /**\n     * Retrives the plugin with the given id or null if not found.\n     *\n     * This function also returns any plugin's that\n     * were defined using the legacy <feature> tags.\n     * @name getPlugin\n     * @function\n     * @param {String} id\n     * @returns {object} plugin including any variables\n     */\n    getPlugin: function(id){\n        if(!id){\n            return undefined;\n        }\n        var pluginElement = this.doc.find('./plugin/[@name=\"' + id + '\"]');\n        if (null === pluginElement) {\n            var legacyFeature =  this.doc.find('./feature/param[@name=\"id\"][@value=\"' + id + '\"]/..');\n            if(legacyFeature){\n                 events.emit('log', 'Found deprecated feature entry for ' + id +' in config.xml.');\n                return featureToPlugin(legacyFeature);\n            }\n            return undefined;\n        }\n        var plugin = {};\n\n        plugin.name = pluginElement.attrib.name;\n        plugin.spec = pluginElement.attrib.spec || pluginElement.attrib.src || pluginElement.attrib.version;\n        plugin.variables = {};\n        var variableElements = pluginElement.findall('variable');\n        variableElements.forEach(function(varElement){\n            var name = varElement.attrib.name;\n            var value = varElement.attrib.value;\n            if(name){\n                plugin.variables[name] = value;\n            }\n        });\n        return plugin;\n    },\n    /**\n     * Remove the plugin entry with give name (id).\n     *\n     * This function also operates on any plugin's that\n     * were defined using the legacy <feature> tags.\n     * @name removePlugin\n     * @function\n     * @param id name of the plugin\n     */\n    removePlugin: function(id){\n        if(id){\n            var plugins = this.doc.findall('./plugin/[@name=\"' + id + '\"]')\n                .concat(this.doc.findall('./feature/param[@name=\"id\"][@value=\"' + id + '\"]/..'));\n            var children = this.doc.getroot().getchildren();\n            plugins.forEach(function (plugin) {\n                var idx = children.indexOf(plugin);\n                if (idx > -1) {\n                    children.splice(idx, 1);\n                }\n            });\n        }\n    },\n\n    // Add any element to the root\n    addElement: function(name, attributes) {\n        var el = et.Element(name);\n        for (var a in attributes) {\n            el.attrib[a] = attributes[a];\n        }\n        this.doc.getroot().append(el);\n    },\n\n    /**\n     * Adds an engine. Does not check for duplicates.\n     * @param  {String} name the engine name\n     * @param  {String} spec engine source location or version (optional)\n     */\n    addEngine: function(name, spec){\n        if(!name) return;\n        var el = et.Element('engine');\n        el.attrib.name = name;\n        if(spec){\n            el.attrib.spec = spec;\n        }\n        this.doc.getroot().append(el);\n    },\n    /**\n     * Removes all the engines with given name\n     * @param  {String} name the engine name.\n     */\n    removeEngine: function(name){\n        var engines = this.doc.findall('./engine/[@name=\"' +name+'\"]');\n        for(var i=0; i < engines.length; i++){\n            var children = this.doc.getroot().getchildren();\n            var idx = children.indexOf(engines[i]);\n            if(idx > -1){\n                children.splice(idx,1);\n            }\n        }\n    },\n    getEngines: function(){\n        var engines = this.doc.findall('./engine');\n        return engines.map(function(engine){\n            var spec = engine.attrib.spec || engine.attrib.version;\n            return {\n                'name': engine.attrib.name,\n                'spec': spec ? spec : null\n            };\n        });\n    },\n    /* Get all the access tags */\n    getAccesses: function() {\n        var accesses = this.doc.findall('./access');\n        return accesses.map(function(access){\n            var minimum_tls_version = access.attrib['minimum-tls-version']; /* String */\n            var requires_forward_secrecy = access.attrib['requires-forward-secrecy']; /* Boolean */\n            var requires_certificate_transparency = access.attrib['requires-certificate-transparency']; /* Boolean */\n            var allows_arbitrary_loads_in_web_content = access.attrib['allows-arbitrary-loads-in-web-content']; /* Boolean */\n            var allows_arbitrary_loads_in_media = access.attrib['allows-arbitrary-loads-in-media']; /* Boolean */\n            var allows_local_networking = access.attrib['allows-local-networking']; /* Boolean */\n            \n            return {\n                'origin': access.attrib.origin,\n                'minimum_tls_version': minimum_tls_version,\n                'requires_forward_secrecy' : requires_forward_secrecy,\n                'requires_certificate_transparency' : requires_certificate_transparency,\n                'allows_arbitrary_loads_in_web_content' : allows_arbitrary_loads_in_web_content,\n                'allows_arbitrary_loads_in_media' : allows_arbitrary_loads_in_media,\n                'allows_local_networking' : allows_local_networking\n            };\n        });\n    },\n    /* Get all the allow-navigation tags */\n    getAllowNavigations: function() {\n        var allow_navigations = this.doc.findall('./allow-navigation');\n        return allow_navigations.map(function(allow_navigation){\n            var minimum_tls_version = allow_navigation.attrib['minimum-tls-version']; /* String */\n            var requires_forward_secrecy = allow_navigation.attrib['requires-forward-secrecy']; /* Boolean */\n            var requires_certificate_transparency = allow_navigation.attrib['requires-certificate-transparency']; /* Boolean */\n\n            return {\n                'href': allow_navigation.attrib.href,\n                'minimum_tls_version': minimum_tls_version,\n                'requires_forward_secrecy' : requires_forward_secrecy,\n                'requires_certificate_transparency' : requires_certificate_transparency\n            };\n        });\n    },\n    /* Get all the allow-intent tags */\n    getAllowIntents: function() {\n        var allow_intents = this.doc.findall('./allow-intent');\n        return allow_intents.map(function(allow_intent){\n            return {\n                'href': allow_intent.attrib.href\n            };\n        });\n    },\n    /* Get all edit-config tags */\n    getEditConfigs: function(platform) {\n        var platform_tag = this.doc.find('./platform[@name=\"' + platform + '\"]');\n        var platform_edit_configs = platform_tag ? platform_tag.findall('edit-config') : [];\n\n        var edit_configs = this.doc.findall('edit-config').concat(platform_edit_configs);\n\n        return edit_configs.map(function(tag) {\n            var editConfig =\n                {\n                    file : tag.attrib['file'],\n                    target : tag.attrib['target'],\n                    mode : tag.attrib['mode'],\n                    id : 'config.xml',\n                    xmls : tag.getchildren()\n                };\n            return editConfig;\n        });\n    },\n    write:function() {\n        fs.writeFileSync(this.path, this.doc.write({indent: 4}), 'utf-8');\n    }\n};\n\nfunction featureToPlugin(featureElement) {\n    var plugin = {};\n    plugin.variables = [];\n    var pluginVersion,\n        pluginSrc;\n\n    var nodes = featureElement.findall('param');\n    nodes.forEach(function (element) {\n        var n = element.attrib.name;\n        var v = element.attrib.value;\n        if (n === 'id') {\n            plugin.name = v;\n        } else if (n === 'version') {\n            pluginVersion = v;\n        } else if (n === 'url' || n === 'installPath') {\n            pluginSrc = v;\n        } else {\n            plugin.variables[n] = v;\n        }\n    });\n\n    var spec = pluginSrc || pluginVersion;\n    if (spec) {\n        plugin.spec = spec;\n    }\n\n    return plugin;\n}\nmodule.exports = ConfigParser;\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/util/xml-helpers.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/ \n\n/* jshint sub:true, laxcomma:true */\n\n/**\n * contains XML utility functions, some of which are specific to elementtree\n */\n\nvar fs = require('fs')\n  , path = require('path')\n  , _ = require('underscore')\n  , et = require('elementtree')\n  ;\n\n  var ROOT = /^\\/([^\\/]*)/,\n      ABSOLUTE = /^\\/([^\\/]*)\\/(.*)/;\n\nmodule.exports = {\n    // compare two et.XML nodes, see if they match\n    // compares tagName, text, attributes and children (recursively)\n    equalNodes: function(one, two) {\n        if (one.tag != two.tag) {\n            return false;\n        } else if (one.text.trim() != two.text.trim()) {\n            return false;\n        } else if (one._children.length != two._children.length) {\n            return false;\n        }\n\n        if (!attribMatch(one, two)) return false;\n\n        for (var i = 0; i < one._children.length; i++) {\n            if (!module.exports.equalNodes(one._children[i], two._children[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    // adds node to doc at selector, creating parent if it doesn't exist\n    graftXML: function(doc, nodes, selector, after) {\n        var parent = module.exports.resolveParent(doc, selector);\n        if (!parent) {\n            //Try to create the parent recursively if necessary\n            try {\n                var parentToCreate = et.XML('<' + path.basename(selector) + '>'),\n                    parentSelector = path.dirname(selector);\n\n                this.graftXML(doc, [parentToCreate], parentSelector);\n            } catch (e) {\n                return false;\n            }\n            parent = module.exports.resolveParent(doc, selector);\n            if (!parent) return false;\n        }\n\n        nodes.forEach(function (node) {\n            // check if child is unique first\n            if (uniqueChild(node, parent)) {\n                var children = parent.getchildren();\n                var insertIdx = after ? findInsertIdx(children, after) : children.length;\n\n                //TODO: replace with parent.insert after the bug in ElementTree is fixed\n                parent.getchildren().splice(insertIdx, 0, node);\n            }\n        });\n\n        return true;\n    },\n\n    // adds new attributes to doc at selector\n    // Will only merge if attribute has not been modified already or --force is used\n    graftXMLMerge: function(doc, nodes, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        // saves the attributes of the original xml before making changes\n        xml.oldAttrib = _.extend({}, target.attrib);\n\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                target.attrib[attribute] = node.attrib[attribute];\n            }\n        });\n\n        return true;\n    },\n\n    // overwrite all attributes to doc at selector with new attributes\n    // Will only overwrite if attribute has not been modified already or --force is used\n    graftXMLOverwrite: function(doc, nodes, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        // saves the attributes of the original xml before making changes\n        xml.oldAttrib = _.extend({}, target.attrib);\n\n        // remove old attributes from target\n        var targetAttributes = target.attrib;\n        for (var targetAttribute in targetAttributes) {\n            delete targetAttributes[targetAttribute];\n        }\n\n        // add new attributes to target\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                target.attrib[attribute] = node.attrib[attribute];\n            }\n        });\n\n        return true;\n    },\n\n    // removes node from doc at selector\n    pruneXML: function(doc, nodes, selector) {\n        var parent = module.exports.resolveParent(doc, selector);\n        if (!parent) return false;\n\n        nodes.forEach(function (node) {\n            var matchingKid = null;\n            if ((matchingKid = findChild(node, parent)) !== null) {\n                // stupid elementtree takes an index argument it doesn't use\n                // and does not conform to the python lib\n                parent.remove(matchingKid);\n            }\n        });\n\n        return true;\n    },\n\n    // restores attributes from doc at selector\n    pruneXMLRestore: function(doc, selector, xml) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        if (xml.oldAttrib) {\n            target.attrib = _.extend({}, xml.oldAttrib);\n        }\n\n        return true;\n    },\n\n    prunXMLRemove: function(doc, selector, nodes) {\n        var target = module.exports.resolveParent(doc, selector);\n        if (!target) return false;\n\n        nodes.forEach(function (node) {\n            var attributes = node.attrib;\n            for (var attribute in attributes) {\n                if (target.attrib[attribute]) {\n                    delete target.attrib[attribute];\n                }\n            }\n        });\n\n        return true;\n\n    },\n\n\n    parseElementtreeSync: function (filename) {\n        var contents = fs.readFileSync(filename, 'utf-8');\n        if(contents) {\n            //Windows is the BOM. Skip the Byte Order Mark.\n            contents = contents.substring(contents.indexOf('<'));\n        }\n        return new et.ElementTree(et.XML(contents));\n    },\n\n    resolveParent: function (doc, selector) {\n        var parent, tagName, subSelector;\n\n        // handle absolute selector (which elementtree doesn't like)\n        if (ROOT.test(selector)) {\n            tagName = selector.match(ROOT)[1];\n            // test for wildcard \"any-tag\" root selector\n            if (tagName == '*' || tagName === doc._root.tag) {\n                parent = doc._root;\n\n                // could be an absolute path, but not selecting the root\n                if (ABSOLUTE.test(selector)) {\n                    subSelector = selector.match(ABSOLUTE)[2];\n                    parent = parent.find(subSelector);\n                }\n            } else {\n                return false;\n            }\n        } else {\n            parent = doc.find(selector);\n        }\n        return parent;\n    }\n};\n\nfunction findChild(node, parent) {\n    var matchingKids = parent.findall(node.tag)\n      , i, j;\n\n    for (i = 0, j = matchingKids.length ; i < j ; i++) {\n        if (module.exports.equalNodes(node, matchingKids[i])) {\n            return matchingKids[i];\n        }\n    }\n    return null;\n}\n\nfunction uniqueChild(node, parent) {\n    var matchingKids = parent.findall(node.tag)\n      , i = 0;\n\n    if (matchingKids.length === 0) {\n        return true;\n    } else  {\n        for (i; i < matchingKids.length; i++) {\n            if (module.exports.equalNodes(node, matchingKids[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n// Find the index at which to insert an entry. After is a ;-separated priority list\n// of tags after which the insertion should be made. E.g. If we need to\n// insert an element C, and the rule is that the order of children has to be\n// As, Bs, Cs. After will be equal to \"C;B;A\".\nfunction findInsertIdx(children, after) {\n    var childrenTags = children.map(function(child) { return child.tag; });\n    var afters = after.split(';');\n    var afterIndexes = afters.map(function(current) { return childrenTags.lastIndexOf(current); });\n    var foundIndex = _.find(afterIndexes, function(index) { return index != -1; });\n\n    //add to the beginning if no matching nodes are found\n    return typeof foundIndex === 'undefined' ? 0 : foundIndex+1;\n}\n\nvar BLACKLIST = ['platform', 'feature','plugin','engine'];\nvar SINGLETONS = ['content', 'author', 'name'];\nfunction mergeXml(src, dest, platform, clobber) {\n    // Do nothing for blacklisted tags.\n    if (BLACKLIST.indexOf(src.tag) != -1) return;\n\n    //Handle attributes\n    Object.getOwnPropertyNames(src.attrib).forEach(function (attribute) {\n        if (clobber || !dest.attrib[attribute]) {\n            dest.attrib[attribute] = src.attrib[attribute];\n        }\n    });\n    //Handle text\n    if (src.text && (clobber || !dest.text)) {\n        dest.text = src.text;\n    }\n    //Handle children\n    src.getchildren().forEach(mergeChild);\n\n    //Handle platform\n    if (platform) {\n        src.findall('platform[@name=\"' + platform + '\"]').forEach(function (platformElement) {\n            platformElement.getchildren().forEach(mergeChild);\n        });\n    }\n\n    //Handle duplicate preference tags (by name attribute)\n    removeDuplicatePreferences(dest);\n\n    function mergeChild (srcChild) {\n        var srcTag = srcChild.tag,\n            destChild = new et.Element(srcTag),\n            foundChild,\n            query = srcTag + '',\n            shouldMerge = true;\n\n        if (BLACKLIST.indexOf(srcTag) !== -1) return;\n\n        if (SINGLETONS.indexOf(srcTag) !== -1) {\n            foundChild = dest.find(query);\n            if (foundChild) {\n                destChild = foundChild;\n                dest.remove(destChild);\n            }\n        } else {\n            //Check for an exact match and if you find one don't add\n            var mergeCandidates = dest.findall(query)\n            .filter(function (foundChild) {\n                return foundChild && textMatch(srcChild, foundChild) && attribMatch(srcChild, foundChild);\n            });\n\n            if (mergeCandidates.length > 0) {\n                destChild = mergeCandidates[0];\n                dest.remove(destChild);\n                shouldMerge = false;\n            }\n        }\n\n        mergeXml(srcChild, destChild, platform, clobber && shouldMerge);\n        dest.append(destChild);\n    }\n\n    function removeDuplicatePreferences(xml) {\n        // reduce preference tags to a hashtable to remove dupes\n        var prefHash = xml.findall('preference[@name][@value]').reduce(function(previousValue, currentValue) {\n            previousValue[ currentValue.attrib.name ] = currentValue.attrib.value;\n            return previousValue;\n        }, {});\n\n        // remove all preferences\n        xml.findall('preference[@name][@value]').forEach(function(pref) {\n            xml.remove(pref);\n        });\n\n        // write new preferences\n        Object.keys(prefHash).forEach(function(key, index) {\n            var element = et.SubElement(xml, 'preference');\n            element.set('name', key);\n            element.set('value', this[key]);\n        }, prefHash);\n    }\n}\n\n// Expose for testing.\nmodule.exports.mergeXml = mergeXml;\n\nfunction textMatch(elm1, elm2) {\n    var text1 = elm1.text ? elm1.text.replace(/\\s+/, '') : '',\n        text2 = elm2.text ? elm2.text.replace(/\\s+/, '') : '';\n    return (text1 === '' || text1 === text2);\n}\n\nfunction attribMatch(one, two) {\n    var oneAttribKeys = Object.keys(one.attrib);\n    var twoAttribKeys = Object.keys(two.attrib);\n\n    if (oneAttribKeys.length != twoAttribKeys.length) {\n        return false;\n    }\n\n    for (var i = 0; i < oneAttribKeys.length; i++) {\n        var attribName = oneAttribKeys[i];\n\n        if (one.attrib[attribName] != two.attrib[attribName]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/node_modules/underscore/underscore.js":"//     Underscore.js 1.8.3\n//     http://underscorejs.org\n//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `exports` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var\n    push             = ArrayProto.push,\n    slice            = ArrayProto.slice,\n    toString         = ObjProto.toString,\n    hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind,\n    nativeCreate       = Object.create;\n\n  // Naked function reference for surrogate-prototype-swapping.\n  var Ctor = function(){};\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.8.3';\n\n  // Internal function that returns an efficient (for current engines) version\n  // of the passed-in callback, to be repeatedly applied in other Underscore\n  // functions.\n  var optimizeCb = function(func, context, argCount) {\n    if (context === void 0) return func;\n    switch (argCount == null ? 3 : argCount) {\n      case 1: return function(value) {\n        return func.call(context, value);\n      };\n      case 2: return function(value, other) {\n        return func.call(context, value, other);\n      };\n      case 3: return function(value, index, collection) {\n        return func.call(context, value, index, collection);\n      };\n      case 4: return function(accumulator, value, index, collection) {\n        return func.call(context, accumulator, value, index, collection);\n      };\n    }\n    return function() {\n      return func.apply(context, arguments);\n    };\n  };\n\n  // A mostly-internal function to generate callbacks that can be applied\n  // to each element in a collection, returning the desired result — either\n  // identity, an arbitrary callback, a property matcher, or a property accessor.\n  var cb = function(value, context, argCount) {\n    if (value == null) return _.identity;\n    if (_.isFunction(value)) return optimizeCb(value, context, argCount);\n    if (_.isObject(value)) return _.matcher(value);\n    return _.property(value);\n  };\n  _.iteratee = function(value, context) {\n    return cb(value, context, Infinity);\n  };\n\n  // An internal function for creating assigner functions.\n  var createAssigner = function(keysFunc, undefinedOnly) {\n    return function(obj) {\n      var length = arguments.length;\n      if (length < 2 || obj == null) return obj;\n      for (var index = 1; index < length; index++) {\n        var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n        for (var i = 0; i < l; i++) {\n          var key = keys[i];\n          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];\n        }\n      }\n      return obj;\n    };\n  };\n\n  // An internal function for creating a new object that inherits from another.\n  var baseCreate = function(prototype) {\n    if (!_.isObject(prototype)) return {};\n    if (nativeCreate) return nativeCreate(prototype);\n    Ctor.prototype = prototype;\n    var result = new Ctor;\n    Ctor.prototype = null;\n    return result;\n  };\n\n  var property = function(key) {\n    return function(obj) {\n      return obj == null ? void 0 : obj[key];\n    };\n  };\n\n  // Helper for collection methods to determine whether a collection\n  // should be iterated as an array or as an object\n  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength\n  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094\n  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n  var getLength = property('length');\n  var isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n  };\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles raw objects in addition to array-likes. Treats all\n  // sparse array-likes as if they were dense.\n  _.each = _.forEach = function(obj, iteratee, context) {\n    iteratee = optimizeCb(iteratee, context);\n    var i, length;\n    if (isArrayLike(obj)) {\n      for (i = 0, length = obj.length; i < length; i++) {\n        iteratee(obj[i], i, obj);\n      }\n    } else {\n      var keys = _.keys(obj);\n      for (i = 0, length = keys.length; i < length; i++) {\n        iteratee(obj[keys[i]], keys[i], obj);\n      }\n    }\n    return obj;\n  };\n\n  // Return the results of applying the iteratee to each element.\n  _.map = _.collect = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length,\n        results = Array(length);\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      results[index] = iteratee(obj[currentKey], currentKey, obj);\n    }\n    return results;\n  };\n\n  // Create a reducing function iterating left or right.\n  function createReduce(dir) {\n    // Optimized iterator function as using arguments.length\n    // in the main function will deoptimize the, see #1991.\n    function iterator(obj, iteratee, memo, keys, index, length) {\n      for (; index >= 0 && index < length; index += dir) {\n        var currentKey = keys ? keys[index] : index;\n        memo = iteratee(memo, obj[currentKey], currentKey, obj);\n      }\n      return memo;\n    }\n\n    return function(obj, iteratee, memo, context) {\n      iteratee = optimizeCb(iteratee, context, 4);\n      var keys = !isArrayLike(obj) && _.keys(obj),\n          length = (keys || obj).length,\n          index = dir > 0 ? 0 : length - 1;\n      // Determine the initial value if none is provided.\n      if (arguments.length < 3) {\n        memo = obj[keys ? keys[index] : index];\n        index += dir;\n      }\n      return iterator(obj, iteratee, memo, keys, index, length);\n    };\n  }\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`.\n  _.reduce = _.foldl = _.inject = createReduce(1);\n\n  // The right-associative version of reduce, also known as `foldr`.\n  _.reduceRight = _.foldr = createReduce(-1);\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, predicate, context) {\n    var key;\n    if (isArrayLike(obj)) {\n      key = _.findIndex(obj, predicate, context);\n    } else {\n      key = _.findKey(obj, predicate, context);\n    }\n    if (key !== void 0 && key !== -1) return obj[key];\n  };\n\n  // Return all the elements that pass a truth test.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, predicate, context) {\n    var results = [];\n    predicate = cb(predicate, context);\n    _.each(obj, function(value, index, list) {\n      if (predicate(value, index, list)) results.push(value);\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, predicate, context) {\n    return _.filter(obj, _.negate(cb(predicate)), context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (!predicate(obj[currentKey], currentKey, obj)) return false;\n    }\n    return true;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Aliased as `any`.\n  _.some = _.any = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = !isArrayLike(obj) && _.keys(obj),\n        length = (keys || obj).length;\n    for (var index = 0; index < length; index++) {\n      var currentKey = keys ? keys[index] : index;\n      if (predicate(obj[currentKey], currentKey, obj)) return true;\n    }\n    return false;\n  };\n\n  // Determine if the array or object contains a given item (using `===`).\n  // Aliased as `includes` and `include`.\n  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {\n    if (!isArrayLike(obj)) obj = _.values(obj);\n    if (typeof fromIndex != 'number' || guard) fromIndex = 0;\n    return _.indexOf(obj, item, fromIndex) >= 0;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      var func = isFunc ? method : value[method];\n      return func == null ? func : func.apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, _.property(key));\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs) {\n    return _.filter(obj, _.matcher(attrs));\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.find(obj, _.matcher(attrs));\n  };\n\n  // Return the maximum element (or element-based computation).\n  _.max = function(obj, iteratee, context) {\n    var result = -Infinity, lastComputed = -Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value > result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iteratee, context) {\n    var result = Infinity, lastComputed = Infinity,\n        value, computed;\n    if (iteratee == null && obj != null) {\n      obj = isArrayLike(obj) ? obj : _.values(obj);\n      for (var i = 0, length = obj.length; i < length; i++) {\n        value = obj[i];\n        if (value < result) {\n          result = value;\n        }\n      }\n    } else {\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index, list) {\n        computed = iteratee(value, index, list);\n        if (computed < lastComputed || computed === Infinity && result === Infinity) {\n          result = value;\n          lastComputed = computed;\n        }\n      });\n    }\n    return result;\n  };\n\n  // Shuffle a collection, using the modern version of the\n  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).\n  _.shuffle = function(obj) {\n    var set = isArrayLike(obj) ? obj : _.values(obj);\n    var length = set.length;\n    var shuffled = Array(length);\n    for (var index = 0, rand; index < length; index++) {\n      rand = _.random(0, index);\n      if (rand !== index) shuffled[index] = shuffled[rand];\n      shuffled[rand] = set[index];\n    }\n    return shuffled;\n  };\n\n  // Sample **n** random values from a collection.\n  // If **n** is not specified, returns a single random element.\n  // The internal `guard` argument allows it to work with `map`.\n  _.sample = function(obj, n, guard) {\n    if (n == null || guard) {\n      if (!isArrayLike(obj)) obj = _.values(obj);\n      return obj[_.random(obj.length - 1)];\n    }\n    return _.shuffle(obj).slice(0, Math.max(0, n));\n  };\n\n  // Sort the object's values by a criterion produced by an iteratee.\n  _.sortBy = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value: value,\n        index: index,\n        criteria: iteratee(value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index - right.index;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(behavior) {\n    return function(obj, iteratee, context) {\n      var result = {};\n      iteratee = cb(iteratee, context);\n      _.each(obj, function(value, index) {\n        var key = iteratee(value, index, obj);\n        behavior(result, value, key);\n      });\n      return result;\n    };\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key].push(value); else result[key] = [value];\n  });\n\n  // Indexes the object's values by a criterion, similar to `groupBy`, but for\n  // when you know that your index values will be unique.\n  _.indexBy = group(function(result, value, key) {\n    result[key] = value;\n  });\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = group(function(result, value, key) {\n    if (_.has(result, key)) result[key]++; else result[key] = 1;\n  });\n\n  // Safely create a real, live array from anything iterable.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (isArrayLike(obj)) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return isArrayLike(obj) ? obj.length : _.keys(obj).length;\n  };\n\n  // Split a collection into two arrays: one whose elements all satisfy the given\n  // predicate, and one whose elements all do not satisfy the predicate.\n  _.partition = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var pass = [], fail = [];\n    _.each(obj, function(value, key, obj) {\n      (predicate(value, key, obj) ? pass : fail).push(value);\n    });\n    return [pass, fail];\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[0];\n    return _.initial(array, array.length - n);\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if (n == null || guard) return array[array.length - 1];\n    return _.rest(array, Math.max(0, array.length - n));\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, n == null || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, strict, startIndex) {\n    var output = [], idx = 0;\n    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {\n      var value = input[i];\n      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {\n        //flatten current level of array or arguments object\n        if (!shallow) value = flatten(value, shallow, strict);\n        var j = 0, len = value.length;\n        output.length += len;\n        while (j < len) {\n          output[idx++] = value[j++];\n        }\n      } else if (!strict) {\n        output[idx++] = value;\n      }\n    }\n    return output;\n  };\n\n  // Flatten out an array, either recursively (by default), or just one level.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, false);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iteratee, context) {\n    if (!_.isBoolean(isSorted)) {\n      context = iteratee;\n      iteratee = isSorted;\n      isSorted = false;\n    }\n    if (iteratee != null) iteratee = cb(iteratee, context);\n    var result = [];\n    var seen = [];\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var value = array[i],\n          computed = iteratee ? iteratee(value, i, array) : value;\n      if (isSorted) {\n        if (!i || seen !== computed) result.push(value);\n        seen = computed;\n      } else if (iteratee) {\n        if (!_.contains(seen, computed)) {\n          seen.push(computed);\n          result.push(value);\n        }\n      } else if (!_.contains(result, value)) {\n        result.push(value);\n      }\n    }\n    return result;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(flatten(arguments, true, true));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var result = [];\n    var argsLength = arguments.length;\n    for (var i = 0, length = getLength(array); i < length; i++) {\n      var item = array[i];\n      if (_.contains(result, item)) continue;\n      for (var j = 1; j < argsLength; j++) {\n        if (!_.contains(arguments[j], item)) break;\n      }\n      if (j === argsLength) result.push(item);\n    }\n    return result;\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = flatten(arguments, true, true, 1);\n    return _.filter(array, function(value){\n      return !_.contains(rest, value);\n    });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    return _.unzip(arguments);\n  };\n\n  // Complement of _.zip. Unzip accepts an array of arrays and groups\n  // each array's elements on shared indices\n  _.unzip = function(array) {\n    var length = array && _.max(array, getLength).length || 0;\n    var result = Array(length);\n\n    for (var index = 0; index < length; index++) {\n      result[index] = _.pluck(array, index);\n    }\n    return result;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    var result = {};\n    for (var i = 0, length = getLength(list); i < length; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // Generator function to create the findIndex and findLastIndex functions\n  function createPredicateIndexFinder(dir) {\n    return function(array, predicate, context) {\n      predicate = cb(predicate, context);\n      var length = getLength(array);\n      var index = dir > 0 ? 0 : length - 1;\n      for (; index >= 0 && index < length; index += dir) {\n        if (predicate(array[index], index, array)) return index;\n      }\n      return -1;\n    };\n  }\n\n  // Returns the first index on an array-like that passes a predicate test\n  _.findIndex = createPredicateIndexFinder(1);\n  _.findLastIndex = createPredicateIndexFinder(-1);\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iteratee, context) {\n    iteratee = cb(iteratee, context, 1);\n    var value = iteratee(obj);\n    var low = 0, high = getLength(array);\n    while (low < high) {\n      var mid = Math.floor((low + high) / 2);\n      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;\n    }\n    return low;\n  };\n\n  // Generator function to create the indexOf and lastIndexOf functions\n  function createIndexFinder(dir, predicateFind, sortedIndex) {\n    return function(array, item, idx) {\n      var i = 0, length = getLength(array);\n      if (typeof idx == 'number') {\n        if (dir > 0) {\n            i = idx >= 0 ? idx : Math.max(idx + length, i);\n        } else {\n            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;\n        }\n      } else if (sortedIndex && idx && length) {\n        idx = sortedIndex(array, item);\n        return array[idx] === item ? idx : -1;\n      }\n      if (item !== item) {\n        idx = predicateFind(slice.call(array, i, length), _.isNaN);\n        return idx >= 0 ? idx + i : -1;\n      }\n      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {\n        if (array[idx] === item) return idx;\n      }\n      return -1;\n    };\n  }\n\n  // Return the position of the first occurrence of an item in an array,\n  // or -1 if the item is not included in the array.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);\n  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (stop == null) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = step || 1;\n\n    var length = Math.max(Math.ceil((stop - start) / step), 0);\n    var range = Array(length);\n\n    for (var idx = 0; idx < length; idx++, start += step) {\n      range[idx] = start;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Determines whether to execute a function as a constructor\n  // or a normal function with the provided arguments\n  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);\n    var self = baseCreate(sourceFunc.prototype);\n    var result = sourceFunc.apply(self, args);\n    if (_.isObject(result)) return result;\n    return self;\n  };\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');\n    var args = slice.call(arguments, 2);\n    var bound = function() {\n      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n    };\n    return bound;\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context. _ acts\n  // as a placeholder, allowing any combination of arguments to be pre-filled.\n  _.partial = function(func) {\n    var boundArgs = slice.call(arguments, 1);\n    var bound = function() {\n      var position = 0, length = boundArgs.length;\n      var args = Array(length);\n      for (var i = 0; i < length; i++) {\n        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];\n      }\n      while (position < arguments.length) args.push(arguments[position++]);\n      return executeBound(func, bound, this, this, args);\n    };\n    return bound;\n  };\n\n  // Bind a number of an object's methods to that object. Remaining arguments\n  // are the method names to be bound. Useful for ensuring that all callbacks\n  // defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var i, length = arguments.length, key;\n    if (length <= 1) throw new Error('bindAll must be passed function names');\n    for (i = 1; i < length; i++) {\n      key = arguments[i];\n      obj[key] = _.bind(obj[key], obj);\n    }\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memoize = function(key) {\n      var cache = memoize.cache;\n      var address = '' + (hasher ? hasher.apply(this, arguments) : key);\n      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);\n      return cache[address];\n    };\n    memoize.cache = {};\n    return memoize;\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){\n      return func.apply(null, args);\n    }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = _.partial(_.delay, _, 1);\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time. Normally, the throttled function will run\n  // as much as it can, without ever going more than once per `wait` duration;\n  // but if you'd like to disable the execution on the leading edge, pass\n  // `{leading: false}`. To disable execution on the trailing edge, ditto.\n  _.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    var previous = 0;\n    if (!options) options = {};\n    var later = function() {\n      previous = options.leading === false ? 0 : _.now();\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      var now = _.now();\n      if (!previous && options.leading === false) previous = now;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0 || remaining > wait) {\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      var last = _.now() - timestamp;\n\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      timestamp = _.now();\n      var callNow = immediate && !timeout;\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return _.partial(wrapper, func);\n  };\n\n  // Returns a negated version of the passed-in predicate.\n  _.negate = function(predicate) {\n    return function() {\n      return !predicate.apply(this, arguments);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function() {\n      var i = start;\n      var result = args[start].apply(this, arguments);\n      while (i--) result = args[i].call(this, result);\n      return result;\n    };\n  };\n\n  // Returns a function that will only be executed on and after the Nth call.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Returns a function that will only be executed up to (but not including) the Nth call.\n  _.before = function(times, func) {\n    var memo;\n    return function() {\n      if (--times > 0) {\n        memo = func.apply(this, arguments);\n      }\n      if (times <= 1) func = null;\n      return memo;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = _.partial(_.before, 2);\n\n  // Object Functions\n  // ----------------\n\n  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.\n  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');\n  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',\n                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];\n\n  function collectNonEnumProps(obj, keys) {\n    var nonEnumIdx = nonEnumerableProps.length;\n    var constructor = obj.constructor;\n    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;\n\n    // Constructor is a special case.\n    var prop = 'constructor';\n    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);\n\n    while (nonEnumIdx--) {\n      prop = nonEnumerableProps[nonEnumIdx];\n      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {\n        keys.push(prop);\n      }\n    }\n  }\n\n  // Retrieve the names of an object's own properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    if (nativeKeys) return nativeKeys(obj);\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve all the property names of an object.\n  _.allKeys = function(obj) {\n    if (!_.isObject(obj)) return [];\n    var keys = [];\n    for (var key in obj) keys.push(key);\n    // Ahem, IE < 9.\n    if (hasEnumBug) collectNonEnumProps(obj, keys);\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var values = Array(length);\n    for (var i = 0; i < length; i++) {\n      values[i] = obj[keys[i]];\n    }\n    return values;\n  };\n\n  // Returns the results of applying the iteratee to each element of the object\n  // In contrast to _.map it returns an object\n  _.mapObject = function(obj, iteratee, context) {\n    iteratee = cb(iteratee, context);\n    var keys =  _.keys(obj),\n          length = keys.length,\n          results = {},\n          currentKey;\n      for (var index = 0; index < length; index++) {\n        currentKey = keys[index];\n        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);\n      }\n      return results;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var keys = _.keys(obj);\n    var length = keys.length;\n    var pairs = Array(length);\n    for (var i = 0; i < length; i++) {\n      pairs[i] = [keys[i], obj[keys[i]]];\n    }\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    var keys = _.keys(obj);\n    for (var i = 0, length = keys.length; i < length; i++) {\n      result[obj[keys[i]]] = keys[i];\n    }\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = createAssigner(_.allKeys);\n\n  // Assigns a given object with all the own properties in the passed-in object(s)\n  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)\n  _.extendOwn = _.assign = createAssigner(_.keys);\n\n  // Returns the first key on an object that passes a predicate test\n  _.findKey = function(obj, predicate, context) {\n    predicate = cb(predicate, context);\n    var keys = _.keys(obj), key;\n    for (var i = 0, length = keys.length; i < length; i++) {\n      key = keys[i];\n      if (predicate(obj[key], key, obj)) return key;\n    }\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(object, oiteratee, context) {\n    var result = {}, obj = object, iteratee, keys;\n    if (obj == null) return result;\n    if (_.isFunction(oiteratee)) {\n      keys = _.allKeys(obj);\n      iteratee = optimizeCb(oiteratee, context);\n    } else {\n      keys = flatten(arguments, false, false, 1);\n      iteratee = function(value, key, obj) { return key in obj; };\n      obj = Object(obj);\n    }\n    for (var i = 0, length = keys.length; i < length; i++) {\n      var key = keys[i];\n      var value = obj[key];\n      if (iteratee(value, key, obj)) result[key] = value;\n    }\n    return result;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj, iteratee, context) {\n    if (_.isFunction(iteratee)) {\n      iteratee = _.negate(iteratee);\n    } else {\n      var keys = _.map(flatten(arguments, false, false, 1), String);\n      iteratee = function(value, key) {\n        return !_.contains(keys, key);\n      };\n    }\n    return _.pick(obj, iteratee, context);\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = createAssigner(_.allKeys, true);\n\n  // Creates an object that inherits from the given prototype object.\n  // If additional properties are provided then they will be added to the\n  // created object.\n  _.create = function(prototype, props) {\n    var result = baseCreate(prototype);\n    if (props) _.extendOwn(result, props);\n    return result;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Returns whether an object has a given set of `key:value` pairs.\n  _.isMatch = function(object, attrs) {\n    var keys = _.keys(attrs), length = keys.length;\n    if (object == null) return !length;\n    var obj = Object(object);\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      if (attrs[key] !== obj[key] || !(key in obj)) return false;\n    }\n    return true;\n  };\n\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\n    if (a === b) return a !== 0 || 1 / a === 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className !== toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, regular expressions, dates, and booleans are compared by value.\n      case '[object RegExp]':\n      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return '' + a === '' + b;\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive.\n        // Object(NaN) is equivalent to NaN\n        if (+a !== +a) return +b !== +b;\n        // An `egal` comparison is performed for other numeric values.\n        return +a === 0 ? 1 / +a === 1 / b : +a === +b;\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a === +b;\n    }\n\n    var areArrays = className === '[object Array]';\n    if (!areArrays) {\n      if (typeof a != 'object' || typeof b != 'object') return false;\n\n      // Objects with different constructors are not equivalent, but `Object`s or `Array`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&\n                               _.isFunction(bCtor) && bCtor instanceof bCtor)\n                          && ('constructor' in a && 'constructor' in b)) {\n        return false;\n      }\n    }\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n\n    // Initializing stack of traversed objects.\n    // It's done here since we only need them for objects and arrays comparison.\n    aStack = aStack || [];\n    bStack = bStack || [];\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] === a) return bStack[length] === b;\n    }\n\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n\n    // Recursively compare objects and arrays.\n    if (areArrays) {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      length = a.length;\n      if (length !== b.length) return false;\n      // Deep compare the contents, ignoring non-numeric properties.\n      while (length--) {\n        if (!eq(a[length], b[length], aStack, bStack)) return false;\n      }\n    } else {\n      // Deep compare objects.\n      var keys = _.keys(a), key;\n      length = keys.length;\n      // Ensure that both objects contain the same number of properties before comparing deep equality.\n      if (_.keys(b).length !== length) return false;\n      while (length--) {\n        // Deep compare each member\n        key = keys[length];\n        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return true;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;\n    return _.keys(obj).length === 0;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.\n  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) === '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE < 9), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return _.has(obj, 'callee');\n    };\n  }\n\n  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n  // IE 11 (#1621), and in Safari 8 (#1929).\n  if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n    _.isFunction = function(obj) {\n      return typeof obj == 'function' || false;\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj !== +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return obj != null && hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iteratees.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Predicate-generating functions. Often useful outside of Underscore.\n  _.constant = function(value) {\n    return function() {\n      return value;\n    };\n  };\n\n  _.noop = function(){};\n\n  _.property = property;\n\n  // Generates a function for a given object that returns a given property.\n  _.propertyOf = function(obj) {\n    return obj == null ? function(){} : function(key) {\n      return obj[key];\n    };\n  };\n\n  // Returns a predicate for checking whether an object has a given set of\n  // `key:value` pairs.\n  _.matcher = _.matches = function(attrs) {\n    attrs = _.extendOwn({}, attrs);\n    return function(obj) {\n      return _.isMatch(obj, attrs);\n    };\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iteratee, context) {\n    var accum = Array(Math.max(0, n));\n    iteratee = optimizeCb(iteratee, context, 1);\n    for (var i = 0; i < n; i++) accum[i] = iteratee(i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // A (possibly faster) way to get the current timestamp as an integer.\n  _.now = Date.now || function() {\n    return new Date().getTime();\n  };\n\n   // List of HTML entities for escaping.\n  var escapeMap = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  var unescapeMap = _.invert(escapeMap);\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  var createEscaper = function(map) {\n    var escaper = function(match) {\n      return map[match];\n    };\n    // Regexes for identifying a key that needs to be escaped\n    var source = '(?:' + _.keys(map).join('|') + ')';\n    var testRegexp = RegExp(source);\n    var replaceRegexp = RegExp(source, 'g');\n    return function(string) {\n      string = string == null ? '' : '' + string;\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\n    };\n  };\n  _.escape = createEscaper(escapeMap);\n  _.unescape = createEscaper(unescapeMap);\n\n  // If the value of the named `property` is a function then invoke it with the\n  // `object` as context; otherwise, return it.\n  _.result = function(object, property, fallback) {\n    var value = object == null ? void 0 : object[property];\n    if (value === void 0) {\n      value = fallback;\n    }\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\n  var escapeChar = function(match) {\n    return '\\\\' + escapes[match];\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  // NB: `oldSettings` only exists for backwards compatibility.\n  _.template = function(text, settings, oldSettings) {\n    if (!settings && oldSettings) settings = oldSettings;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset).replace(escaper, escapeChar);\n      index = offset + match.length;\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      } else if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      } else if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n\n      // Adobe VMs need the match returned to produce the correct offest.\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + 'return __p;\\n';\n\n    try {\n      var render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled source as a convenience for precompilation.\n    var argument = settings.variable || 'obj';\n    template.source = 'function(' + argument + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function. Start chaining a wrapped Underscore object.\n  _.chain = function(obj) {\n    var instance = _(obj);\n    instance._chain = true;\n    return instance;\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(instance, obj) {\n    return instance._chain ? _(obj).chain() : obj;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    _.each(_.functions(obj), function(name) {\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];\n      return result(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  _.each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  // Extracts the result from a wrapped and chained object.\n  _.prototype.value = function() {\n    return this._wrapped;\n  };\n\n  // Provide unwrapping proxy for some methods used in engine operations\n  // such as arithmetic and JSON stringification.\n  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;\n\n  _.prototype.toString = function() {\n    return '' + this._wrapped;\n  };\n\n  // AMD registration happens at the end for compatibility with AMD loaders\n  // that may not enforce next-turn semantics on modules. Even though general\n  // practice for AMD registration is to be anonymous, underscore registers\n  // as a named module because, like jQuery, it is a base library that is\n  // popular enough to be bundled in a third party lib, but not be part of\n  // an AMD load request. Those cases could generate an error when an\n  // anonymous define() is called outside of a loader request.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore', [], function() {\n      return _;\n    });\n  }\n}.call(this));\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova-common/src/PluginInfo/PluginInfo.js":"/**\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\n/* jshint sub:true, laxcomma:true, laxbreak:true */\n\n/*\nA class for holidng the information currently stored in plugin.xml\nIt should also be able to answer questions like whether the plugin\nis compatible with a given engine version.\n\nTODO (kamrik): refactor this to not use sync functions and return promises.\n*/\n\n\nvar path = require('path')\n  , fs = require('fs')\n  , xml_helpers = require('../util/xml-helpers')\n  , CordovaError = require('../CordovaError/CordovaError')\n  ;\n\nfunction PluginInfo(dirname) {\n    var self = this;\n\n    // METHODS\n    // Defined inside the constructor to avoid the \"this\" binding problems.\n\n    // <preference> tag\n    // Example: <preference name=\"API_KEY\" />\n    // Used to require a variable to be specified via --variable when installing the plugin.\n    // returns { key : default | null}\n    self.getPreferences = getPreferences;\n    function getPreferences(platform) {\n        return _getTags(self._et, 'preference', platform, _parsePreference)\n        .reduce(function (preferences, pref) {\n            preferences[pref.preference] = pref.default;\n            return preferences;\n        }, {});\n    }\n\n    function _parsePreference(prefTag) {\n        var name = prefTag.attrib.name.toUpperCase();\n        var def = prefTag.attrib.default || null;\n        return {preference: name, default: def};\n    }\n\n    // <asset>\n    self.getAssets = getAssets;\n    function getAssets(platform) {\n        var assets = _getTags(self._et, 'asset', platform, _parseAsset);\n        return assets;\n    }\n\n    function _parseAsset(tag) {\n        var src = tag.attrib.src;\n        var target = tag.attrib.target;\n\n        if ( !src || !target) {\n            var msg =\n                'Malformed <asset> tag. Both \"src\" and \"target\" attributes'\n                + 'must be specified in\\n'\n                + self.filepath\n                ;\n            throw new Error(msg);\n        }\n\n        var asset = {\n            itemType: 'asset',\n            src: src,\n            target: target\n        };\n        return asset;\n    }\n\n\n    // <dependency>\n    // Example:\n    // <dependency id=\"com.plugin.id\"\n    //     url=\"https://github.com/myuser/someplugin\"\n    //     commit=\"428931ada3891801\"\n    //     subdir=\"some/path/here\" />\n    self.getDependencies = getDependencies;\n    function getDependencies(platform) {\n        var deps = _getTags(\n                self._et,\n                'dependency',\n                platform,\n                _parseDependency\n        );\n        return deps;\n    }\n\n    function _parseDependency(tag) {\n        var dep =\n            { id : tag.attrib.id\n            , url : tag.attrib.url || ''\n            , subdir : tag.attrib.subdir || ''\n            , commit : tag.attrib.commit\n            };\n\n        dep.git_ref = dep.commit;\n\n        if ( !dep.id ) {\n            var msg =\n                '<dependency> tag is missing id attribute in '\n                + self.filepath\n                ;\n            throw new CordovaError(msg);\n        }\n        return dep;\n    }\n\n\n    // <config-file> tag\n    self.getConfigFiles = getConfigFiles;\n    function getConfigFiles(platform) {\n        var configFiles = _getTags(self._et, 'config-file', platform, _parseConfigFile);\n        return configFiles;\n    }\n\n    function _parseConfigFile(tag) {\n        var configFile =\n            { target : tag.attrib['target']\n            , parent : tag.attrib['parent']\n            , after : tag.attrib['after']\n            , xmls : tag.getchildren()\n            // To support demuxing via versions\n            , versions : tag.attrib['versions']\n            , deviceTarget: tag.attrib['device-target']\n            };\n        return configFile;\n    }\n\n    self.getEditConfigs = getEditConfigs;\n    function getEditConfigs(platform) {\n        var editConfigs = _getTags(self._et, 'edit-config', platform, _parseEditConfigs);\n        return editConfigs;\n    }\n\n    function _parseEditConfigs(tag) {\n        var editConfig =\n        { file : tag.attrib['file']\n        , target : tag.attrib['target']\n        , mode : tag.attrib['mode']\n        , xmls : tag.getchildren()\n        };\n        return editConfig;\n    }\n\n    // <info> tags, both global and within a <platform>\n    // TODO (kamrik): Do we ever use <info> under <platform>? Example wanted.\n    self.getInfo = getInfo;\n    function getInfo(platform) {\n        var infos = _getTags(\n                self._et,\n                'info',\n                platform,\n                function(elem) { return elem.text; }\n        );\n        // Filter out any undefined or empty strings.\n        infos = infos.filter(Boolean);\n        return infos;\n    }\n\n    // <source-file>\n    // Examples:\n    // <source-file src=\"src/ios/someLib.a\" framework=\"true\" />\n    // <source-file src=\"src/ios/someLib.a\" compiler-flags=\"-fno-objc-arc\" />\n    self.getSourceFiles = getSourceFiles;\n    function getSourceFiles(platform) {\n        var sourceFiles = _getTagsInPlatform(self._et, 'source-file', platform, _parseSourceFile);\n        return sourceFiles;\n    }\n\n    function _parseSourceFile(tag) {\n        return {\n            itemType: 'source-file',\n            src: tag.attrib.src,\n            framework: isStrTrue(tag.attrib.framework),\n            weak: isStrTrue(tag.attrib.weak),\n            compilerFlags: tag.attrib['compiler-flags'],\n            targetDir: tag.attrib['target-dir']\n        };\n    }\n\n    // <header-file>\n    // Example:\n    // <header-file src=\"CDVFoo.h\" />\n    self.getHeaderFiles = getHeaderFiles;\n    function getHeaderFiles(platform) {\n        var headerFiles = _getTagsInPlatform(self._et, 'header-file', platform, function(tag) {\n            return {\n                itemType: 'header-file',\n                src: tag.attrib.src,\n                targetDir: tag.attrib['target-dir']\n            };\n        });\n        return headerFiles;\n    }\n\n    // <resource-file>\n    // Example:\n    // <resource-file src=\"FooPluginStrings.xml\" target=\"res/values/FooPluginStrings.xml\" device-target=\"win\" arch=\"x86\" versions=\"&gt;=8.1\" />\n    self.getResourceFiles = getResourceFiles;\n    function getResourceFiles(platform) {\n        var resourceFiles = _getTagsInPlatform(self._et, 'resource-file', platform, function(tag) {\n            return {\n                itemType: 'resource-file',\n                src: tag.attrib.src,\n                target: tag.attrib.target,\n                versions: tag.attrib.versions,\n                deviceTarget: tag.attrib['device-target'],\n                arch: tag.attrib.arch,\n                reference: tag.attrib.reference\n            };\n        });\n        return resourceFiles;\n    }\n\n    // <lib-file>\n    // Example:\n    // <lib-file src=\"src/BlackBerry10/native/device/libfoo.so\" arch=\"device\" />\n    self.getLibFiles = getLibFiles;\n    function getLibFiles(platform) {\n        var libFiles = _getTagsInPlatform(self._et, 'lib-file', platform, function(tag) {\n            return {\n                itemType: 'lib-file',\n                src: tag.attrib.src,\n                arch: tag.attrib.arch,\n                Include: tag.attrib.Include,\n                versions: tag.attrib.versions,\n                deviceTarget: tag.attrib['device-target'] || tag.attrib.target\n            };\n        });\n        return libFiles;\n    }\n\n    // <hook>\n    // Example:\n    // <hook type=\"before_build\" src=\"scripts/beforeBuild.js\" />\n    self.getHookScripts = getHookScripts;\n    function getHookScripts(hook, platforms) {\n        var scriptElements =  self._et.findall('./hook');\n\n        if(platforms) {\n            platforms.forEach(function (platform) {\n                scriptElements = scriptElements.concat(self._et.findall('./platform[@name=\"' + platform + '\"]/hook'));\n            });\n        }\n\n        function filterScriptByHookType(el) {\n            return el.attrib.src && el.attrib.type && el.attrib.type.toLowerCase() === hook;\n        }\n\n        return scriptElements.filter(filterScriptByHookType);\n    }\n\n    self.getJsModules = getJsModules;\n    function getJsModules(platform) {\n        var modules = _getTags(self._et, 'js-module', platform, _parseJsModule);\n        return modules;\n    }\n\n    function _parseJsModule(tag) {\n        var ret = {\n            itemType: 'js-module',\n            name: tag.attrib.name,\n            src: tag.attrib.src,\n            clobbers: tag.findall('clobbers').map(function(tag) { return { target: tag.attrib.target }; }),\n            merges: tag.findall('merges').map(function(tag) { return { target: tag.attrib.target }; }),\n            runs: tag.findall('runs').length > 0\n        };\n\n        return ret;\n    }\n\n    self.getEngines = function() {\n        return self._et.findall('engines/engine').map(function(n) {\n            return {\n                name: n.attrib.name,\n                version: n.attrib.version,\n                platform: n.attrib.platform,\n                scriptSrc: n.attrib.scriptSrc\n            };\n        });\n    };\n\n    self.getPlatforms = function() {\n        return self._et.findall('platform').map(function(n) {\n            return { name: n.attrib.name };\n        });\n    };\n\n    self.getPlatformsArray = function() {\n        return self._et.findall('platform').map(function(n) {\n            return n.attrib.name;\n        });\n    };\n    self.getFrameworks = function(platform) {\n        return _getTags(self._et, 'framework', platform, function(el) {\n            var ret = {\n                itemType: 'framework',\n                type: el.attrib.type,\n                parent: el.attrib.parent,\n                custom: isStrTrue(el.attrib.custom),\n                src: el.attrib.src,\n                spec: el.attrib.spec,\n                weak: isStrTrue(el.attrib.weak),\n                versions: el.attrib.versions,\n                targetDir: el.attrib['target-dir'],\n                deviceTarget: el.attrib['device-target'] || el.attrib.target,\n                arch: el.attrib.arch,\n                implementation: el.attrib.implementation\n            };\n            return ret;\n        });\n    };\n\n    self.getFilesAndFrameworks = getFilesAndFrameworks;\n    function getFilesAndFrameworks(platform) {\n        // Please avoid changing the order of the calls below, files will be\n        // installed in this order.\n        var items = [].concat(\n            self.getSourceFiles(platform),\n            self.getHeaderFiles(platform),\n            self.getResourceFiles(platform),\n            self.getFrameworks(platform),\n            self.getLibFiles(platform)\n        );\n        return items;\n    }\n    ///// End of PluginInfo methods /////\n\n\n    ///// PluginInfo Constructor logic  /////\n    self.filepath = path.join(dirname, 'plugin.xml');\n    if (!fs.existsSync(self.filepath)) {\n        throw new CordovaError('Cannot find plugin.xml for plugin \"' + path.basename(dirname) + '\". Please try adding it again.');\n    }\n\n    self.dir = dirname;\n    var et = self._et = xml_helpers.parseElementtreeSync(self.filepath);\n    var pelem = et.getroot();\n    self.id = pelem.attrib.id;\n    self.version = pelem.attrib.version;\n\n    // Optional fields\n    self.name = pelem.findtext('name');\n    self.description = pelem.findtext('description');\n    self.license = pelem.findtext('license');\n    self.repo = pelem.findtext('repo');\n    self.issue = pelem.findtext('issue');\n    self.keywords = pelem.findtext('keywords');\n    self.info = pelem.findtext('info');\n    if (self.keywords) {\n        self.keywords = self.keywords.split(',').map( function(s) { return s.trim(); } );\n    }\n    self.getKeywordsAndPlatforms = function () {\n        var ret = self.keywords || [];\n        return ret.concat('ecosystem:cordova').concat(addCordova(self.getPlatformsArray()));\n    };\n}  // End of PluginInfo constructor.\n\n// Helper function used to prefix every element of an array with cordova-\n// Useful when we want to modify platforms to be cordova-platform\nfunction addCordova(someArray) {\n    var newArray = someArray.map(function(element) {\n        return 'cordova-' + element;\n    });\n    return newArray;\n}\n\n// Helper function used by most of the getSomething methods of PluginInfo.\n// Get all elements of a given name. Both in root and in platform sections\n// for the given platform. If transform is given and is a function, it is\n// applied to each element.\nfunction _getTags(pelem, tag, platform, transform) {\n    var platformTag = pelem.find('./platform[@name=\"' + platform + '\"]');\n    var tagsInRoot = pelem.findall(tag);\n    tagsInRoot = tagsInRoot || [];\n    var tagsInPlatform = platformTag ? platformTag.findall(tag) : [];\n    var tags = tagsInRoot.concat(tagsInPlatform);\n    if ( typeof transform === 'function' ) {\n        tags = tags.map(transform);\n    }\n    return tags;\n}\n\n// Same as _getTags() but only looks inside a platform section.\nfunction _getTagsInPlatform(pelem, tag, platform, transform) {\n    var platformTag = pelem.find('./platform[@name=\"' + platform + '\"]');\n    var tags = platformTag ? platformTag.findall(tag) : [];\n    if ( typeof transform === 'function' ) {\n        tags = tags.map(transform);\n    }\n    return tags;\n}\n\n// Check if x is a string 'true'.\nfunction isStrTrue(x) {\n    return String(x).toLowerCase() == 'true';\n}\n\nmodule.exports = PluginInfo;\n// Backwards compat:\nPluginInfo.PluginInfo = PluginInfo;\nPluginInfo.loadPluginsDir = function(dir) {\n    var PluginInfoProvider = require('./PluginInfoProvider');\n    return new PluginInfoProvider().getAllWithinSearchPath(dir);\n};\n","/home/travis/build/npmtest/node-npmtest-cordova/node_modules/cordova/src/create.js":"/*\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n    distributed with this work for additional information\n    regarding copyright ownership.  The ASF licenses this file\n    to you under the Apache License, Version 2.0 (the\n    \"License\"); you may not use this file except in compliance\n    with the License.  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing,\n    software distributed under the License is distributed on an\n    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n    KIND, either express or implied.  See the License for the\n    specific language governing permissions and limitations\n    under the License.\n*/\n\nvar CordovaCliCreate = function () {\n\n}; \n\n/**\n * provides logic for exposing cordova-lib create functionality to the command line\n * the create argument is implied from the call to this function, all other cl arguments should be passed in unmodified\n * \n * @args  - \n * @undashed \n */\nCordovaCliCreate.prototype.run = function (args, undashed) {\n    var cfg = {},\n        customWww;\n\n    // parseConfig will determine if there's a valid config JSON string\n    cfg = this.parseConfig(undashed[4]);\n    \n    // create(dir, id, name, cfg)\n    cordova.raw.create(undashed[1] , // dir to create the project in\n                       undashed[2] , // App id\n                       undashed[3] , // App name\n                       cfg\n    ).done();\n};\n\n/**\n * parseConfig\n * generic parser, if it's valid json, returns the resulting object\n * if anything resolving to false is passed in, return an empty object \n * invalid json results in an error message and process exit with status code 2.\n *\n * jsondata - a json data string\n *\n */\nCordovaCliCreate.prototype.parseConfig = function (jsondata) {\n    if (!jsondata) return {};\n\n    try {\n        cfg = JSON.parse(jsondata);\n    } catch (e) {\n        console.error('Error while parsing json data\\nError: '+ e +'\\nData:' + jsondata);\n        process.exit(2); \n    }\n};\nCordovaCliCreate.prototype.customWww = function (args) {\n\n    // handle custom www\n    if (!!(customWww = args['copy-from'] || args['link-to'])) {\n\n        if (customWww.indexOf(':') != -1) {\n            throw new CordovaError(\n            'Only local paths for custom www assets are supported.'\n            );\n\n        }\n\n        if ( customWww.substr(0,1) === '~' ) {  // resolve tilde in a naive way.\n            customWww = path.join(process.env.HOME,  customWww.substr(1));\n        }\n\n        customWww = path.resolve(customWww);\n        var wwwCfg = { uri: customWww };\n        if (args['link-to']) {\n            wwwCfg.link = true;\n        }\n\n        cfg.lib = cfg.lib || {};\n        cfg.lib.www = wwwCfg;\n    }\n};\n\nmodule.exports = new CordovaCliCreate();\n"}